# 黑马面面项目

## 01-介绍

### 相关资源

1. 后台接口仓库地址：链接
2. 后台接口文档地址：链接
3. 设计稿图片

### 项目开发流程

1. 立项

2. 流程图

   产品根据功能绘制出实现功能需要经历的各个步骤。

   ![](H:%5C%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF47%E6%9C%9F%5C%E4%B8%AA%E4%BA%BA%5C%E6%80%BB%E7%BB%93%5C%E5%89%8D%E7%AB%AFweb%E6%80%BB%E7%BB%93%E6%B1%87%E6%80%BB%5C%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB%5Cimages%5C%E9%BB%91%E9%A9%AC%E9%9D%A2%E9%9D%A2%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

3. 原型图

   产品根据业务流程产出原型图，绝大多数的交互效果能够体现出来。(原型图可以体现交互效果，但是基本不会涉及数据的操纵)

   ![](H:%5C%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF47%E6%9C%9F%5C%E4%B8%AA%E4%BA%BA%5C%E6%80%BB%E7%BB%93%5C%E5%89%8D%E7%AB%AFweb%E6%80%BB%E7%BB%93%E6%B1%87%E6%80%BB%5C%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB%5Cimages%5C%E9%BB%91%E9%A9%AC%E9%9D%A2%E9%9D%A2%E9%A1%B9%E7%9B%AE%E5%8E%9F%E5%9E%8B%E5%9B%BE.png)

   ![](H:%5C%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF47%E6%9C%9F%5C%E4%B8%AA%E4%BA%BA%5C%E6%80%BB%E7%BB%93%5C%E5%89%8D%E7%AB%AFweb%E6%80%BB%E7%BB%93%E6%B1%87%E6%80%BB%5C%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB%5Cimages%5C%E9%BB%91%E9%A9%AC%E9%9D%A2%E9%9D%A2%E9%A1%B9%E7%9B%AE%E5%8E%9F%E5%9E%8B%E5%9B%BE2.png)

4. 视觉稿

   设计师根据产品原型，设计出效果图，实现布局的时候就参照这个来做。

   ![](H:%5C%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF47%E6%9C%9F%5C%E4%B8%AA%E4%BA%BA%5C%E6%80%BB%E7%BB%93%5C%E5%89%8D%E7%AB%AFweb%E6%80%BB%E7%BB%93%E6%B1%87%E6%80%BB%5C%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB%5Cimages%5C%E9%BB%91%E9%A9%AC%E9%9D%A2%E9%9D%A2%E9%A1%B9%E7%9B%AE%E8%A7%86%E8%A7%89%E5%9B%BE.png)

5. 搭建架构

   前后端高级设计师(架构师)根据产品的需求，搭建架构，比如功能模块的抽取，功能文件夹的划分。

6. 技术选型

   前后端根据产品的需求，根据团队的技术储备，选择适合的技术，比如vue、vuex、element-ui、axios、vue-router。

7. 协作开发

   用上一步选择的技术栈去实现具体的业务逻辑。开始代码开发。

8. 测试

   自己测试没有问题之后，交给测试检查，测bug，改bug。

9. 部署与和运维

   把打包好的项目上传到服务器，并且保证项目的正常运行

10. 项目迭代和更新

    实现新增功能

## 02-项目初始化

### 本地接口部署

​	为了方便开发，把后台接口部署到本地方便调用，后续打包时，再切换在线地址。

1. 安装`phpStudy2018`
   * 版本需要是这个，低版本无法设置php的版本信息
   * 已经安装省略

2. 打开`phpStudy2018`
   * 启动Apache、MySQL

3. 进入`MySQL管理器`
   * 点击`MySQL管理器`；
   * 选择`Mysql-Front`；
   * 在弹出的界面选择默认选项，点击`打开`；

4. 新建数据库
   * 右键`localhost`-->`新建`-->`数据库；
   * 新建数据库`heimamm`；
   * 编码格式一定要是`utf8；

5. 导入数据
   * 右键`heimamm->输入->SQL文件`；
   * 克隆后台接口到本地；
   * 导入项目中的`heimamm.sql`；
   * 编码格式`utf-8`；

6. 选择版本

1. * 在`phpStudy2018`主界面选择`切换版本`

1. * 选择`php-7.1.13-nts + Apache`

1. * 因为开发的语言是这个版本
   * ![](H:%5C%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF47%E6%9C%9F%5C%E4%B8%AA%E4%BA%BA%5C%E6%80%BB%E7%BB%93%5C%E5%89%8D%E7%AB%AFweb%E6%80%BB%E7%BB%93%E6%B1%87%E6%80%BB%5C%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB%5Cimages%5CphpStudy2018%E7%89%88%E6%9C%AC.png)

7. 拷贝接口

1. * 在主界面点击`其他选项菜单->网站根目录`

1. * 进入到`www`目录

2. * 将刚刚克隆到本地的项目拷贝到这个目录下面
   * ![](H:%5C%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF47%E6%9C%9F%5C%E4%B8%AA%E4%BA%BA%5C%E6%80%BB%E7%BB%93%5C%E5%89%8D%E7%AB%AFweb%E6%80%BB%E7%BB%93%E6%B1%87%E6%80%BB%5C%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB%5Cimages%5CphpStudy2018%E7%BD%91%E7%AB%99%E6%A0%B9%E7%9B%AE%E5%BD%95.png)

8. 测试访问

1. * 在确保主界面的`MySQL`和`Apache`都启动成功的情况下

1. * 打开浏览器访问`http://127.0.0.1/heimamm/public/captcha?type=login`

1. * 能看到验证码说明开启成功
   * ![](H:%5C%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF47%E6%9C%9F%5C%E4%B8%AA%E4%BA%BA%5C%E6%80%BB%E7%BB%93%5C%E5%89%8D%E7%AB%AFweb%E6%80%BB%E7%BB%93%E6%B1%87%E6%80%BB%5C%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB%5Cimages%5C%E9%BB%91%E9%A9%AC%E9%9D%A2%E9%9D%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E5%9B%BE.png)

### 创建项目

​	 通过 vue-cli 脚手架创建项目 

1.  保证安装了脚手架`vue-cli` 

```bash
# 安装命令
npm install -g @vue/cli
# 检查版本
vue --version
```

2. 创建项目 

   2.1 在终端中输入命令创建项目 

   ```bash
   # 使用vue-cli创建项目
   vue create heimamm
   ```

   ​	2.1.2 选择创建模式

   1. * **default:**默认配置

   1. * **Manually:**自定义选择各项配置

   

   2.2 使用`vue-ui`图形界面创建项目

   ```bash
   # 使用vue-ui创建项目
   # 安装vue-router、vuex、element-ui运行插件
   # 安装axios运行依赖 安装less、less-loader开发依赖(解析less语法)
   ```

3. 安装完毕后，在终端中输入命令

```bash
# 切换到heimamm目录中
cd heimamm
# 运行项目
npm run serve
```

### 项目结构

```bash
| .gitignore  Git忽略配置文件
| package-lock.json
| package.json
| README.md
| 
|-node_modules
|-public
|		favicon.ico 字体图标
|		index.html html文件
|
|-src 源目录
	|-assets 静态资源目录
	|		logo.png
	|
	|-components 非路由全局组件目录
	|
	|-plugins element-ui插件
	|		element.js
	|
	|-router 路由目录
	|		index.js
	|
	|-store Vuex目录
	|		index.js
	|
	| App.vue 根组件
	| main.js 入口模块

```

### 运行项目

​	启动项目时，是这样读取文件的

1. 找到`main.js`；
2. 加载根组件`App`；
3. 创建`Vue`实例；
4. 将根组件替换到`/public/index.html`页面中id为`app`的div内部

### 创建远程仓库

​	除了本地使用git记录之外，远程仓库也保存一份。

1. 创建远程仓库(以github为例)；
2. `public`或者`privite`根据自己需求选择；
3. `README.md`不用勾选，创建项目时已经创建完毕；
4. `.gitignore`不用勾选，创建项目时已经创建完毕；
5. `license`根据需求选择即可，先不勾选。

### 提交到远程仓库

远程仓库创建完毕后，将本地代码进行提交

1. 在终端中输入命令，完成`初始提交`

```bash
git remote add origin 远程仓库地址
git push -u origin master
```

2. 开发过程中，需要进行本地历史记录，通过以下命令实现

```bash
git add .
git commit -m "说明信息"
```

3. 推送到远程，并且**分支**和**远程仓库**都没有改变，通过以下命令实现

```bash
git push	
```

4. 推送到远程，**远程仓库**或者**分支**改变了，实现以下命令实现

```bash
git push -u 远程仓库 分支名
```

### 调整src结构

```bash
src 源码目录
  |- assets 资源目录
  |- components 非 路由页面 组件目录
+ |- style 全局样式目录
+ |- views 路由页面 组件目录
  |- router 路由目录
  |- App.vue 根组件
  |- main.js 入口模块
  |- package.json
```

### 设置基地址

​	在项目根目录创建`.env.development`文件夹(开发环境基地址)

```javascript
VUE_APP_BASEURL=http://127.0.0.1/heimamm/public
```

​	在项目根目录创建`env.production`文件夹(生成环境基地址)

```javascript
VUE_APP_BASEURL=
```

### 设置ESlint语法检查

​	在根目录创建`.prettierrc`文件

```javascript
{
    "semi": false,
    "singleQuote": true,
    "printWidth": 248
}
```

### git记录空目录

​	git无法提交空目录，需要在空目录文件夹下创建`gitkeep`文件才会被git进行跟踪javas

```bash
src 源码目录
  |- assets 资源目录
  |- components 非 路由页面 组件目录
+ |- style 全局样式目录
+   |- .gitkeep 
+ |- views 路由页面 组件目录
+   |- .gitkeep
  |- router 路由目录
  |- App.vue 根组件
  |- main.js 入口模块
```

## 03-接口api抽取

### 在`src`文件下创建`utils`文件夹

1. 创建`token.js`文件，设置、获取、清除token

```javascript
// 常量KEY
const KEY = 'mmtoken'
// 暴露 保存token
export function setToken(token) {
  console.log('token:', token)
  window.localStorage.setItem(KEY, token)
}
// 暴露 获取token
export function getToken() {
  return window.localStorage.getItem(KEY)
}
// 暴露 删除token
export function removeToken() {
  window.localStorage.removeItem(KEY)
}
```

### 在`src`文件下创建`api`文件夹

1. 创建`request.js`文件，使用**axios**拦截器携带**token**以及导航守卫

```javascript
import axios from 'axios'
// 携带token
import { getToken, removeToken } from '@/utils/token.js'
import router from '@/router/index.js'
import { Message } from 'element-ui'

console.log('getToken:', getToken())
// 创建axios对象副本
const instance = axios.create({
  // 基地址
  baseURL: process.env.VUE_APP_BASEURL,
  // 跨域携带cookie
  withCredentials: true
})

// axios请求拦截器
instance.interceptors.request.use(config => {
    // 设置token
    if (getToken()) {
      console.log('是否有token', getToken())
      config.headers.token = getToken()
    }
    return config
  },
  // 捕获错误信息
  error => Promise.reject(error)
)
// axios响应拦截器
instance.interceptors.response.use(response => {
    // 路由导航守卫 无token或无效token，跳转登录页
    if (response.data.code === 206) {
      Message.warning(response.data.message)
      // 移除token
      removeToken()
      // 跳转登录页
      router.push('/login')
    }
    return response.data
  },
  error => Promise.reject(error)
)

// 暴露axios创建的副本对象
export default instance
```

2. 创建`login.js`文件(登录接口)

```javascript
// 导入 request接口对象
import request from './request.js'

// 登录接口
export function login(data) {
  return request({
    url: '/login',
    method: 'post',
    data
  })
}

// 短信接口
export function sendsms(data) {
  return request({
    url: '/sendsms',
    method: 'post',
    data
  })
}

// 用户注册接口
export function register(data) {
  return request({
    url: '/register',
    method: 'post',
    data
  })
}

// 获取用户信息
export function userinfo() {
  return request({
    url: '/info',
    method: 'get'
  })
}

// 退出登录
export function logout() {
  return request({
    url: '/logout',
    method: 'get'
  })
}

```

3. 创建`subject.js`文件(学科列表接口)

```javascript
// 导入request接口
import request from './request.js'

// 暴露 学科列表接口
export function subjectList(params) {
  return request({
    url: '/subject/list',
    method: 'get',
    params
  })
}

// 暴露 添加学科接口
export function subjectAdd(data) {
  return request({
    url: '/subject/add',
    method: 'post',
    data
  })
}

// 暴露 学科状态接口
export function subjectStatus(statusId) {
  return request({
    url: '/subject/status',
    method: 'post',
    data: {
      id: statusId
    }
  })
}

// 暴露 学科编辑接口
export function subjectEdit(data) {
  return request({
    url: '/subject/edit',
    method: 'post',
    data
  })
}

// 暴露 学科删除接口
export function subjectRemove(subjectId) {
  return request({
    url: '/subject/remove',
    method: 'post',
    data: {
      id: subjectId
    }
  })
}
```

4. 创建`enterprise.js`文件(企业列表接口)

```javascript
// 导入axios接口
import request from './request.js'

// 暴露 企业列表接口
export function enterpriseList(params) {
  return request({
    url: '/enterprise/list',
    method: 'get',
    params
  })
}

// 暴露 企业添加接口
export function enterpriseAdd(data) {
  return request({
    url: '/enterprise/add',
    method: 'post',
    data
  })
}

// 暴露 企业设置接口
export function enterpriseStatus(statusId) {
  return request({
    url: '/enterprise/status',
    method: 'post',
    data: {
      id: statusId
    }
  })
}

// 暴露 企业删除接口
export function enterpriseRemove(removeId) {
  return request({
    url: '/enterprise/remove',
    method: 'post',
    data: {
      id: removeId
    }
  })
}

// 暴露 企业编辑接口
export function enterpriseEdit(data) {
  return request({
    url: '/enterprise/edit',
    method: 'post',
    data
  })
}
```

5. 创建`question.js`文件(题库列表接口)

```javascript
// 导入axios接口
import request from './request'

// 暴露 题目列表接口
export function questionList(params) {
  return request({
    url: '/question/list',
    method: 'get',
    params
  })
}

// 暴露 题目发布接口
export function questionAdd(data) {
  return request({
    url: '/question/add',
    method: 'post',
    data
  })
}

// 暴露 获取题目信息接口
export function questionOne(questionId) {
  return request({
    url: '/question/one',
    method: 'post',
    data: {
      id: questionId
    }
  })
}

// 暴露 题目状态接口
export function questionStatus(statusId) {
  return request({
    url: '/question/status',
    method: 'post',
    data: {
      id: statusId
    }
  })
}

// 暴露 删除题目接口
export function questionRemove(removeId) {
  return request({
    url: '/question/remove',
    method: 'post',
    data: {
      id: removeId
    }
  })
}

// 暴露 题目编辑接口
export function questionEdit(data) {
  return request({
    url: '/question/edit',
    method: 'post',
    data
  })
}

// 暴露 题目上传文件接口
export function questionUpload(fileUrl) {
  return request({
    url: '/question/upload',
    method: 'post',
    data: {
      file: fileUrl
    }
  })
}
```

6. 创建`user.js`文件(用户列表接口)

```javascript
// 导入request接口
import request from './request.js'

// 获取用户列表
export function userList(params) {
  return request({
    url: '/user/list',
    method: 'get',
    params
  })
}

// 暴露 添加用户接口
export function userAdd(data) {
  return request({
    url: '/user/add',
    method: 'post',
    data
  })
}

// 暴露设置用户状态接口
export function userStatus(statusId) {
  return request({
    url: '/user/status',
    method: 'post',
    data: {
      id: statusId
    }
  })
}

// 暴露删除用户接口
export function userRemove(removeId) {
  return request({
    url: '/user/remove',
    method: 'post',
    data: {
      id: removeId
    }
  })
}

// 暴露编辑用户接口
export function userEdit(data) {
  return request({
    url: '/user/edit',
    method: 'post',
    data
  })
}
```

7. 创建`chart.js`文件(数据概述接口)

```javascript
// 导入axios接口
import request from './request'

// 数据面板接口
export function dataTitle() {
  return request({
    url: '/data/title',
    method: 'post'
  })
}

// 企业题目统计
export function dataEnterprise() {
  return request({
    url: '/data/statistics',
    method: 'post'
  })
}

// 热门城市
export function dataHotCity() {
  return request({
    url: '/data/hot_cities',
    method: 'post'
  })
}
```

## 04-登录模块

### 创建**login**分支

```bash
# 创建login分支
git branch login
# 切换到login分支
git checkout login
```

### 路由整合

​	登录页面是通过路由来管理的，需要进行路由关联

1. 创建页面组件
   1. 在`views`文件夹下新创建`login`文件夹；
   2. 在`login`文件夹下新创建`login.vue`组件

```javascript
// login组件骨架
<template>
  <div>登录</div>
</template>

<script>
export default {
    name:"login"
}
</script>

<style lang="less">
</style>
```

2. 增加路由规则
   1. 在`router`文件夹下的`index.js`文件添加**login**路由规则；
   2. 路由地址：`/login`

```javascript
/* 这里只展示添加路由规则部分代码*/
// 导入 login 组件
import login from '../views/login/login.vue'

// 创建路由规则
const routes = [
  // login
  {
    path:'/login',
    component:login
  }
];
```

3. 添加`router-view`占位符
   1. 登录页和首页是平级的，`App.vue`作为出口即可；
   2. 在根组件`App.vue`内部增加`router-view`，将组件渲染出来即可

```javascript
<template>
  <router-view></router-view>
</template>

<script>
export default {
  name:'app'
}
</script>

<style lang="less">
</style>
```

4. 检查运行结果
   1. 终端运行 **npm run serve**；
   2. 浏览器访问

5. git保存

```javascript
git add .
git commit -m "登录模块--整合login路由"
```

### 页面布局

1. 视觉效果图

![](H:%5C%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF47%E6%9C%9F%5C%E4%B8%AA%E4%BA%BA%5C%E6%80%BB%E7%BB%93%5C%E5%89%8D%E7%AB%AFweb%E6%80%BB%E7%BB%93%E6%B1%87%E6%80%BB%5C%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB%5Cimages%5C01-%E7%99%BB%E5%BD%95.png)

2. 编写位置：
   1. 当前组件页面样式直接写在组件的**style**内部，且给**style**标签添加一个属性**lang="less"**解析less语法；
   2. 全局样式写在`assets/style/base.css`，且在`main.js`导入全局样式；
   3. 组件最外层使用一个**div**包住，样式在该**div**内部编写。

3. 需要用到的**element-ui**组件有：
   1. 典型**Form表单**；
   2. 带icon的**Input'输入框**；
   3. **Layout布局**；
   4. **Link文字链接**

### Form表单验证

​	数据提交之前需要对表单的内容进行验证，使用**element-ui**提供的表单验证

1. 普通验证

   若只是需要验证长度、非空验证直接使用默认即可

2. 自定义校验规则

   若希望使用自定义的方式进行表单验证，使用自定义校验规则(如验证手机号码格式，电子邮箱格式)

3. 提交表单时验证

   在点击登录时需对最终表单内容做一次验证，成功之后才可以提交，错误则提示用户

4. 用户提示

   默认提示并不美观，使用**element-ui**中的**Message**提示框

5. 步骤：

   1. **data**中定义校验规则；

   2. 在`utils`文件夹中新创建`validator.js`文件，编写自定验证规则；

      ```javascript
      // 暴露手机验证格式
      export function phoneCheck(rule, val, callback) {
        // 验证手机的正则表达式
        const regMobile = /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$/
        if (regMobile.test(val)) {
          return callback()
        } else {
          return callback(new Error('请输入正确手机号码格式'))
        }
      }
      
      // TODO: 暴露勾选同意按钮验证
      export function checkedAgree(rule, val, callback) {
        if (val) {
          return callback()
        } else {
          return callback(new Error('请先勾选同意'))
        }
      }
      ```

   3. 按需导入`validator.js`中的{ **phoneCheck**, **checkedAgree** }

   4. 在**el-form-item**标签使用属性**prop**配置验证数据；

   5. 点击提交按钮时，调用**el-form**的表单验证方法。

```html
<!-- 登录form -->
<el-form ref="loginRef" :model="loginForm" class="login-form" :rules="loginRules">
  <el-form-item prop="phone">
    <el-input prefix-icon="el-icon-user" v-model="loginForm.phone" size="large" placeholder="请输入手机号码"></el-input>
  </el-form-item>
  <el-form-item prop="password">
    <el-input show-password prefix-icon="el-icon-lock" v-model="loginForm.password" placeholder="请输入密码"></el-input>
  </el-form-item>
  <el-row>
    <el-col :span="17">
      <el-form-item prop="code">
        <el-input prefix-icon="el-icon-key" v-model="loginForm.code" placeholder="请输入验证码"></el-input>
      </el-form-item>
    </el-col>
    <el-col :span="7">
      <img :src="loginActions" alt="验证码" class="captcha" @click="loginCaptcha" />
    </el-col>
  </el-row>
  <el-form-item class="check" prop="checked">
    <el-checkbox v-model="loginForm.checked">
      我已阅读并同意
      <el-link type="primary">用户协议</el-link>和
      <el-link type="primary">隐私协议</el-link>
    </el-checkbox>
  </el-form-item>
  <el-form-item>
    <el-button type="primary" class="btn-login" @click="loginBtn">登录</el-button>
    <el-button class="btn-register" @click="registerBtn">注册</el-button>
  </el-form-item>
</el-form>
```

```javascript
/* data中的表单数据 */
// 登录表单对象
loginForm: {
  phone: '18522222222',
  password: '12345678',
  code: '',
  checked: false
},
// 登录输入框规则验证
loginRules: {
  // 号码输入框
  phone: [{ required: true, message: '手机号码不能为空', trigger: 'blur' }, { validator: phoneCheck }],
  // 密码
  password: [{ required: true, message: '密码不能为空', trigger: 'blur' }, { min: 6, max: 12, message: '密码长度为6~12个字符', trigger: 'change' }],
  // 验证码
  code: [{ required: true, message: '验证码不能为空', trigger: 'blur' }, { min: 4, max: 4, message: '验证码长度为4', trigger: 'change' }],
  // 勾选
  checked: [{ validator: checkedAgree }]
},

/* methods中的登录方法 */
// 按钮-登录
loginBtn() {
  this.$refs.loginRef.validate(valid => {
    if (!valid) {
      return this.$message.error('请输入正确登录信息')
    } else {
      login(this.loginForm).then(res => {
        if (res.code === 200) {
          console.log('用户登录', res)
          userinfo().then(res => {
            if (res.data.status === 1) {
              this.$message.success('登录成功')
            }
          })
          // 按需导入token.js文件中的setToken方法，设置token
          setToken(res.data.token)
          // 编程式导航，成功则跳转到index路由
          this.$router.push('/index')
        } else if (res.code === 202) {
          let tip = { 验证码错误: '验证码错误', 登录密码不匹配: '手机号码或密码错误' }
          this.$message.error(tip[res.message])
        }
      })
    }
  })
},
```

### 验证码获取

​	验证码并不是固定的图片，是服务器动态返回。步骤：

* **data**定义验证码地址**actions**，值为**process.env_VUE_APP_BASEURL** +验证码接口地址

```html
<img :src="actions" class="captcha" alt="" />
```

点击重新获取

* 为图片绑定点击事件；
* 为了避免浏览器的缓存，在地址后面拼接随机数或者时间戳

```html
<!-- 验证码 -->
<img :src="loginActions" alt="验证码" class="captcha" @click="loginCaptcha" />
```

```javascript
// data中的登录验证码
// 登录验证码
loginActions: process.env.VUE_APP_BASEURL + '/captcha?type=login'

// methods的方法
// 更换验证码
loginCaptcha() {
  // 随机数
  this.loginActions = this.loginActions + '&_t=' + Math.random()
  // 时间戳
  this.loginActions = this.loginActions + '&_t=' + Date.now()
},
```

### git记录

```bash
# 存储到暂存区
git add .
# 提交到本地仓库
git commit -m "登录模块--完成登录模块功能"
# 切换到主分支
git checkout master
# 合并登录模块分支
git merge login
# 删除登录模块分支
git branch -d login
```

## 05-登录验证模块

### 创建**checkLogin**分支

```bash
# 创建checkLogin分支
git branch checkLogin
# 切换到checkLogin分支
git checkout checkLogin
```

### 首页路由整合

​	登录的判断决定了用户是否可以访问首页，先把页面的组件和规则整合起来。

* 增加管理页面的组件及路由规则

```javascript
// 登录页
[
  // 路由重定向
  {
      path: '/',
      redirect: '/login'
  },
  {
    path:"/login",
        component:login
  },
  // 首页
  {
    path:"/index",
        component:index
  },
]
```

### 接口token判断

​	在`request.js`文件中，在**axios**拦截器中对**token**进行判断：

1. 判断**token**是否为空，为空编程式导航跳转到首页；
2. 判断**token**是否为伪造，伪造也跳转到首页。

```javascript
// axios请求拦截器
instance.interceptors.request.use(config => {
    // 设置token
    if (getToken()) {
      console.log('是否有token', getToken())
      config.headers.token = getToken()
    }
    return config
  },
  // 捕获错误信息
  error => Promise.reject(error)
)
// axios响应拦截器
instance.interceptors.response.use(response => {
    // 路由导航守卫 无token或无效token，跳转登录页
    if (response.data.code === 206) {
      Message.warning(response.data.message)
      // 移除token
      removeToken()
      // 跳转登录页
      router.push('/login')
    }
    return response.data
  },
  error => Promise.reject(error)
)
```

### 导航守卫判断token

​	Vue的声明周期钩子执行的时机是Vue实例的出生到结束，若使用了**router**，便会有更早的钩子，叫做**导航守卫**.。

1. 代码分析：
   1. 导航守卫是路由改变时会执行回调函数；
   2. **to**是去的路由信息；
   3. **from**是来的路由信息；
   4. **next**继续执行的回调函数

2. 在`router/index.js`文件下，编写以下代码：

```javascript
// 增加导航守卫
router.beforeEach((to, from, next) => {
  // 首页才需要判断token
  if (to.path === "/index") {
    if (!getToken()) {
      Message.error("必须登录才可以访问首页");
      return next("/login");
    }
    // token正确性判断
    userinfo().then(res=>{
        if(res.data.code===0){
            // token验证失效
            Message.error("登录状态有误，请重新登录")
            // 删除错误的token
            removeToken()
            // 跳转去登录页
            next('/login')
        }else{
            // token验证成功
            next()
        }
    })
  } else {
    // 放过去
    next();
  }
});
```

3. 注意：
   1. 导航守卫**next**必须执行，否则页面不会跳转；
   2. 导航守卫添加的位置必须在创建好路由对象之后；

### 地址白名单

​	一般来说后台项目中，需要登录的页面居多，不需要登录的页面较少，比如登录、注册等是不要登录的。

1. 步骤：
   1. 在`router/index.js`文件中的导航守卫上方添加**地址白名单**数组；
   2. 导航守卫中判断是否存在白名单，不存在就需要判断。

```javascript
// 地址白名单
const whitePaths = ['/login']
// 增加导航守卫
router.beforeEach((to, from, next) => {
  // 首页才需要判断token
  if (!whitePaths.includes(to.path)) {
    if (!getToken()) {
      Message.error("必须登录才可以访问首页");
      return next("/login");
    }
    // token正确性判断
    userInfo().then(res=>{
        if(res.data.code===0){
            // token验证失效
            Message.error("登录状态有误，请重新登录")
            // 删除错误的token
            removeToken()
            // 跳转去登录页
            next('/login')
        }else{
            // token验证成功
            next()
        }
    })
  } else {
    // 放过去
    next();
  }
});
```

2. 注意：
   1. 后续若要增加允许访问的地址，只需要添加数组中的地址即可；
   2. 若要对路由做更为精细的判断，就不建议通过地址来处理了，可以使用元信息，后续完善。

### Vuex用户数据存储

​	用户信息数据通过**Vuex**来实现共享。

* 在`store/index.js`文件中编写以下代码：

```javascript
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    // 存储用户数据信息
    userInfo: ''
  },
  mutations: {
    setInfo(state, info) {
      // 通过mutation操作用户数据信息
      state.userInfo = info
    }
  }
})

```

* 在`index.vue`文件组件中编写以下代码：

```javascript
// 获取用户信息
   getUserInfo() {
     userinfo().then(res => {
       console.log('用户信息：', res)
       if (res.code === 200) {
         // 给图片设置基地址
         res.data.avatar = `${process.env.VUE_APP_BASEURL}/${res.data.avatar}`
         // 将获取的用户信息数据存储到Vuex中
         this.$store.commit('setInfo', res.data)
       }
     })
   },
```

### git记录

```bash
git add .
git commit -m "登录模块-登录验证功能完成"
git checkout master
git merge checkLogin
git branch -d checkLogin
```

## 06-用户注册

### 创建**register**分支

```bash
# 创建register分支
git branch register
# 切换到register分支
git checkout register
```

### 页面布局

​	注册页面是一个弹出框，不需要整合路由，使用对话框来完成。

1. 需使用的**element-ui**组件：
   * 对话框；
   * 文件上传
   * form表单
   * layout-基本布局
   * layout-分栏偏移

2. 注意：
   * 单文件组件内部的样式也会在全家导入；
   * 样式的编写建议写在页面顶级容器内部，限制作用域。

### 头像上传

​	用户头像上传并不需要设置什么，头像上传用的是**element-ui**的上传组件。

```html
<el-upload
        name="image"
        class="avatar-uploader"
        :action="imgUrl"
        :show-file-list="false"
        :on-success="handleAvatarSuccess"
        :before-upload="beforeAvatarUpload">
        <img v-if="picUrl" :src="picUrl" class="avatar" />
        <i v-else class="el-icon-plus avatar-uploader-icon"></i>
      </el-upload>
```

代码说明：

1. **name**：根据接口文档设置的键名；
2. **action**：图片上传地址；
3. **on-success**：图片上传成功回调函数；
   * 可以在该回调函数中进行图片预览；
   * 同时把服务器返回的图片地址设置给即将要提交的表单。

4. **before-upload**：图片上传之前执行的回调函数
   * 可以进行图片验证

```javascript
// 头像上传成功
handleAvatarSuccess(res, file) {
  // 头像上传成功预览
  this.picUrl = URL.createObjectURL(file.raw)
  if (res.code === 200) {
    this.$message.success('头像上传成功')
    this.registerForm.avatar = res.data.file_path
  } else {
    return this.$message.error('头像上传失败，请重新上传')
  }
},
// 头像上传之前
beforeAvatarUpload(file) {
  const isJPG = file.type === 'image/jpeg'
  const isLt2M = file.size / 1024 / 1024 < 2
  // 限制头像上传格式
  if (!isJPG) {
    this.$message.error('上传头像图片只能为jpg格式')
  }
  // 限制头像上传大小
  if (!isLt2M) {
    this.$message.error('上传图片大小不能超过2MB！')
  }
  return isJPG && isLt2M
}
```

### 图形码验证

​	手机验证码的获取必须首先通过验证码的判断，这部分和之前图形码获取基本一样。

1. 步骤：
   * 为图片设置**src**地址；
   * 设置的地址预定义在**data**中；
   * 绑定点击事件，通过拼接时间戳或者随机数方式避免缓存重新获取图片。

```javascript
// 注册更换验证码
registerCaptcha() {
  this.registerActions = this.registerActions + '&_t=' + Math.random()
},
```

2. 注意：注册验证码接口中的**type**与登录的接口的**type**是不一样的。

```bash
#登录图形码
/captcha?type=login 
#短信图形码
/captcha?type=sendsms 
```

### 验证码获取

1. 步骤：
   * 为验证码按钮绑定点击事件；
   * 验证图形码的正确性(本地验证)；
   * 验证手机号格式的正确性(正则验证)
   * 调用短信接口
   * 开启定时器，15秒之后才能继续使用；

```html
<el-button @click="getCaptcha">{{delayTime ===0?'获取用户验证码': `${delayTime}S`}}</el-button>
```

```javascript
// 获取验证码
getCaptcha() {
  // 先判断图形验证码是否有输入以及手机号码格式
  if (this.registerForm.code.length !== 4) {
    return this.$message.warning('验证码有误')
  }
  // 验证手机的正则表达式
  const regMobile = /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$/
  if (!regMobile.test(this.registerForm.phone)) {
    return this.$message.warning('手机号码格式有误')
  }
  sendsms({ code: this.registerForm.code, phone: this.registerForm.phone }).then(res => {
    if (res.code === 200) {
      if (this.delayTime === 0) {
        this.delayTime = 15
        let timeId = setInterval(() => {
          this.delayTime--
          if (this.delayTime === 0) {
            clearInterval(timeId)
          }
        }, 1000)
      }
      this.registerForm.rcode = res.data.captcha
    } else {
      return this.$message.error(res.message)
    }
  })
},
```

### 表单验证

 验证码获取成功之后，本地表单验证，通过再调用接口提交数据，减轻服务器压力。

1. 表单中的字段要与接口需要字段一致；
2. 步骤：
   1. **data**中增加验证规则**rules**;
   2. **el-form-item**标签通过**prop**属性配置对对应规则；
   3. 点击确认时调用验证方法进行最终验证；
      * 验证成功：继续下一步；
      * 验证失败：提示用户

### 提交用户注册

1. 步骤：
   1. 在上一步表单验证通过之后，调用接口；
   2. 根据结果进行弹出不同的提示框；
   3. 清空表单内容；
   4. 关闭对话框

```javascript
// 按钮-确定注册
ensureRegister() {
  this.$refs.registerRef.validate(valid => {
    if (!valid) {
      return this.$message.error('请完善注册信息')
    }
    console.log('注册参数：', this.registerForm)
    register(this.registerForm).then(res => {
      console.log('注册用户res:', res)
      if (res.code === 200) {
        this.registerDlVisible = false
        this.$refs.registerRef.resetFields()
        this.picUrl = ''
        this.$message.success('注册成功')
      } else if (res.code === 201) {
        return this.$message.warning(res.message)
      } else {
        return this.$message.error('注册失败')
      }
    })
  })
}
```

2. 注意：用户预览头像的字段不在表单中，需要额外清空。

### git记录

```bash
git add .
git commit -m "用户注册模块--用户注册功能完成"
git checkout master
git merge register
git branch -d register
```

## 07-首页模块

### 创建**index**分支

```bash
# 创建index分支
git branch index
# 切换到index分支
git checkout index
```

### 整体布局

1. 步骤：
   1. **index.vue**中增加**element-ui**提供的布局容器；
   2. 可以使用色块先行填充，盒子会自行撑开；
   3. 给页面设置高度**100%**铺满整个页面。

```html
<el-container>
  <el-header>Header</el-header>
  <el-container>
    <el-aside width="200px">Aside</el-aside>
    <el-main>Main</el-main>
  </el-container>
</el-container>
```

2. 注意：
   * 若嵌套元素很多，设置高度时需要多给几个元素；

### 顶部布局

1. 步骤：

   1. 左右各一个盒子；
   2. 父盒子使用弹性布局，让两边顶格；

   ```bash
   justify-content: space-between;
   ```

   3. 左右两个盒子也使用弹性布局，让内容上下居中即可；

2. 注意：
   1. 头像是圆形的；
   2. 左侧的图标是**element-ui**的字体图标；
   3. 修改字体图标大小即可变大

### 用户信息渲染

​	用户登录成功之后跳转到首页，将**Vuex**的用户信息渲染到右上角

```html
<div class="user-info">
    <img class="avatay" :src="userInfo.avatar" />
    <span class="info">{{userInfo.username}}，你好</span>
    <el-button type="primary" size="small" @click="logoutBtn">退出</el-button>
</div>
```

行内直接通过仓库获取用户信息数据语法较长，使用计算属性

```javascript
computed: {
  // 处理用户信息
  userInfo() {
    return this.$store.state.userInfo
  }
}
```

### 用户退出

​	正常用户的退出会通过点击退出按钮

1. 步骤：

   1. 在请求拦截器中判断用户信息并携带**token**

      * 用户信息获取依赖于`store/index.js`
      * **token**获取依赖`utils/token.js`

   2. 为退出按钮绑定点击事件；

   3. 弹出**MessageBox**

      * 点击确定：
        * 调用退出接口；
        * 删除token；
        * 删除用户信息
        * 跳转到登录页

      * 点击取消：不执行逻辑，提示用户取消退出

```javascript
// 创建axios对象副本
const instance = axios.create({
  // 基地址
  baseURL: process.env.VUE_APP_BASEURL,
  // 跨域携带cookie
  withCredentials: true
})

// axios请求拦截器
instance.interceptors.request.use(config => {
    // 设置token
    if (getToken()) {
      console.log('是否有token', getToken())
      config.headers.token = getToken()
    }
    return config
  },
  // 捕获错误信息
  error => Promise.reject(error)
)
// axios响应拦截器
instance.interceptors.response.use(response => {
    // 路由导航守卫 无token或无效token，跳转登录页
    if (response.data.code === 206) {
      Message.warning(response.data.message)
      // 移除token
      removeToken()
      // 跳转登录页
      router.push('/login')
    }
    return response.data
  },
  error => Promise.reject(error)
)
```

```javascript
// 退出登录
async logoutBtn() {
  let confirmRes = await this.$confirm('是否退出登录?', '提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  }).catch(err => err)
  console.log(confirmRes)
  if (confirmRes !== 'confirm') {
    return this.$message.info('已取消退出登录')
  }
  logout().then(res => {
    if (res.code === 200) {
      this.$message.success('已退出登录')
      this.$router.push('/login')
      removeToken()
      // 将Vuex中的值清空
      this.$store.commit('setInfo', '')
    }
  })
},
```

4. 注意：
   * **token**和用户信息若不删除，后续直接输入地址还是可以访问首页；
   * 退出登录接口需要携带**token**，并且后续很多接口都需要携带，使用**axiso**拦截器统一进行设置

### 左侧布局

​	左侧布局使用**element-ui**的导航栏结合图标来实现

* 步骤：

1. 拷贝基本结构到左侧
2. 根据视觉设计稿修改内容
3. 结合图标调整左侧图标

### 导航菜单--折叠功能

​	若左侧影响了视觉，可以将它折叠起来。

1. 步骤：
   1. 通过**collapse**关联一个布尔值，通过修改布尔值实现展开和关闭；

2. 注意：
   1. 折叠功能是导航菜单提供的默认功能，使用时需要结合样式；
   2. 侧边栏的宽度默认有一个行内，要自适应需要调整**width: auto**
   3. 若宽度删除默认给添加一个**300px**

### 导航菜单--router模式及数据渲染

​	导航菜单的数据渲染来源路由，对路由中的元信息进行设置后再渲染

1. 步骤：
   1. 对首页路由规则进行添加子路由；
   2. 给对应的子路由设置元信息；
   3. 元信息包含菜单导航中的**title、字体图标、路由、角色**；
   4. 在导航菜单上设置**router**属性；
   5. 使用**v-for**循环元信息中的路由进行渲染；
   6. 在`views/`文件夹下创建对应路由组件。

```javascript
// 配置meta字段
export default [
  // 登录页
  {
    path: '/',
    redirect: '/login'
  },
  {
    path: '/login',
    component: login,
    meta: {
      roles: ['超级管理员', '管理员', '老师', '学生']
    }
  },
  // 首页
  {
    path: '/index',
    component: index,
    redirect: '/index/subject',
    // 嵌套路由
    children: [{
      // 数据概述
      path: '/index/chart',
      component: chart,
      meta: {
        title: '数据概述',
        icon: 'el-icon-pie-chart',
        fullPath: '/index/chart',
        roles: ['超级管理员', '管理员', '老师']
      }
    }, {
      // 用户列表
      path: '/index/user',
      component: user,
      meta: {
        title: '用户列表',
        icon: 'el-icon-user',
        fullPath: '/index/user',
        roles: ['超级管理员', '管理员']
      }
    }, {
      // 题库列表
      path: '/index/question',
      component: question,
      meta: {
        title: '题库列表',
        icon: 'el-icon-edit-outline',
        fullPath: '/index/question',
        roles: ['超级管理员', '管理员', '老师', '学生']
      }
    }, {
      // 企业列表
      path: '/index/enterprise',
      component: enterprise,
      meta: {
        title: '企业列表',
        icon: 'el-icon-notebook-2',
        fullPath: '/index/enterprise',
        roles: ['超级管理员', '管理员', '老师']
      }
    }, {
      // 学科列表
      path: '/index/subject',
      component: subject,
      meta: {
        title: '学科列表',
        icon: 'el-icon-office-building',
        fullPath: '/index/subject',
        roles: ['超级管理员', '管理员', '老师']
      }
    }]
  }
]
```

```html
<el-aside width="auto">
  <el-aside width="auto">
    <el-menu
      :collapse="isCollapse"
      :default-active="$route.path"
      class="el-menu-vertical-demo"
      router>
      <template v-for="(item, index) in routes[2].children">
        <el-menu-item
          v-if="item.meta.roles.includes($store.state.userInfo.role)"
          :index="item.meta.fullPath"
          :key="index">
          <i :class="item.meta.icon"></i>
          <span slot="title">{{item.meta.title}}</span>
        </el-menu-item>
      </template>
    </el-menu>
  </el-aside>
</el-aside>
```

### git记录

```bash
git add .
git commit -m"首页模块--首页模块布局、路由功能完成"
git checkout master
git merge index
git branch -d index
```

## 08-学科列表模块

### 创建**subject**分支

```bash
git branch subject
git checkout subject
```

### 页面布局

​	开始写逻辑之前，先把布局写好。

1. 使用的**element-ui**组件：
   * **element-ui卡片**；
   * **element-ui行内表单**
   * **element-ui表格**
   * **element-ui表格-自定义列模板**
   * **element-ui分页**

2. 步骤：
   * 使用**element-ui**将**卡片**上下的布局写好；
   * 在上面的**卡片**容器中使用**elemment-ui**的**行内表单**设置结构；
   * 在下面**卡片**容器中使用**element-ui**的**table**来设置；
   * 在**table**内部的按钮，需要使用自定义列表模板(及作用于插槽)；
   * 在底部**table**使用**分页**实现分页效果。

3. 注意：
   * 自定义列表模板使用的语法是Vue提供的**插槽**；
   * **表单、表格、分页**都需要绑定对应的数据，否则会有错误提示。

### 初始数据获取

​	一进入页面便发送请求获取学科数据。

1. 步骤：
   1. 导入`@/api/subject.js`中的学科列表接口；
   2. 在**created**钩子中获取数据；
   3. **data**中增加总页数，并且在获取数据时为其赋值；
   4. **总页数**设置给分页组件；
   5. 调整**table**表头的属性，使之与数据相对应。

```javascript
methods: {
  // 发送请求获取学科列表数据函数
  getSubjectList() {
    subjectList(this.subjectForm).then(res => {
      console.log('学科列表数据', res)
      if (res.code !== 200) {
        return this.$message.warning('获取学科列表失败')
      }
      this.subjectList = res.data.items
      this.total = res.data.pagination.total
    })
  },
},
 created() {
    // 调用请求学科数据函数
    this.getSubjectList()
  }
```

2. 注意：
   * 这部分数据获取不需要做任何处理，服务器有默认值；
   * 创建事件的格式若想调整，可以使用过滤器进行格式化时间格式；
   * **table**内部的内容修改需要通过**slot-scope**获取当前行的数据进行修改。

### 过滤器抽取

​	时间格式若想更改格式，可以通过过滤器实现，根据过滤器的使用位置，分为全局和局部。时间处理使用**moment**来实现。

1. 步骤：
   * 安装**moment.js**
   * 创建`filters/filters.js`
   * 编写过滤器
   * `main.js`导入
   * 在需要的地方使用过滤器即可

```javascript
// 过滤器
// 导入Vue
import Vue from 'vue'
// 导入Moment.js
import moment from 'moment'

// 注册全局过滤器
Vue.filter('formatTime',v=>{
    return moment(v).format("YYYY年MM月DD日")
})
```

```html
<!-- table中使用过滤器 -->
<el-table-column label="创建日期">
  <template slot-scope="scope">
    {{ scope.row.create_time | formatTime }}
  </template>
</el-table-column>
```

2. 注意：
   * 时间处理格式根据需求来设置即可；
   * **element-ui**中的**table**中使用过滤器需要结合插槽来使用才可以。

### 数据分页

​	点击上一页、下一页，修改页容量需要重新获取数据。

1. 步骤：
   * 分页组件的页码，页容量绑定到**data**中的数据；
   * 点击切换页码，切换页容量时将**data**中的数据更新，同时调用接口即可；

```javascript
// 页码尺寸改变触发
 handleSizeChange(newSize) {
   this.subjectForm.limit = newSize
   this.getSubjectList()
 },
 // 页码改变触发
 handleCurrentChange(newPage) {
   this.subjectForm.page = newPage
   this.getSubjectList()
 }
```

2. **注意**：页容量改变时，重新去第一页，更符合用户体验。

### 数据新增

​	点击弹出新增框，输入内容，验证通过之后就需要添加数据了。

1. 步骤：
   1. 新创建`addSubject.vue`组件，并且组件整合到`subject.vue`父组件中
   2. 导入新增接口**addSubject**到数据组件addSubject.vue
   3. 整合对话框**dialog**到学科页面
   4. 通过父组件的**布尔值**控制显示隐藏
   5. 调整表单结构
   6. 绑定表单数据**addSubjectForm**
   7. 整合表单验证**rules**
   8. 点击提交进行表单验证
      1. 错误：提示用户
      2. 正确：调用接口提交数据
         1. 重置表单
         2. 通过父组件的**布尔值**控制关闭对话框
         3. 重新获取数据

```javascript
// 确认新增学科
ensureAddSubject() {
  this.$refs.addSubjectRef.validate(valid => {
    if (!valid) {
      return this.$message.warning('请完善学科信息')
    }
    subjectAdd(this.addSubjectForm).then(res => {
      console.log('新增学科：', res)
      if (res.code === 200) {
        this.$message.success('新增学科成功')
        this.$parent.getSubjectList()
        this.$parent.subjectDlVisible = false
        this.$refs.addSubjectRef.resetFields()
      } else if (res.code === 201) {
        this.$message.warning('学科编号已存在')
      } else {
        this.$message.error('新增学科失败')
      }
    })
  })
}
```

2. 注意：必须的字段根据接口文档来设置。

### 状态修改

​	点击禁用和启用需要同步调整数据的状态。

1. 步骤：
   1. 导入接口**subjectStatus**
   2. 为状态修改按钮绑定点击事件
   3. 调用状态修改接口
   4. 提交成功之后重新获取数据即可
   5. 若有必要弹框提醒下用户

```html
<el-table-column label="状态">
	<template slot-scope="scope">
		<span v-if="scope.row.status===1">启用</span>
		<span v-else class="forbidden">禁用</span>
	</template>
 </el-table-column>
<el-table-column label="操作">
	<template slot-scope="scope">
		 <el-button type="text" @click="editSubject(scope.row)">编辑</el-button>
		 <el-button type="text" @click="changeStatus(scope.row)">{{scope.row.status==0?'启用': '禁用'}}</el-button>
		 <el-button type="text" @click="removeSubject(scope.row)">删除</el-button>
	</template>
</el-table-column>
```

2. 注意：
   1. 状态改变之后，需要重新获取数据
   2. 为了用户体验更好，状态文字和按钮的文字根据状态修改成不同的样式

### 数据筛选

​	当数据变多时，需要对其进行筛选。

1. 步骤：
   1. 为筛选表单绑定数据；
   2. 点击筛选调用数据列表接口，传递筛选的数据去服务器
   3. 点击清空调用表单的**resetFields()**方法即可

```html
<el-form :inline="true" :model="subjectForm" class="demo-form-inline" ref="subjectRef">
	<el-form-item label="学科编号" prop="rid">
		<el-input v-model="subjectForm.rid"></el-input>
	</el-form-item>
	<el-form-item label="学科名称" prop="name">
		<el-input v-model="subjectForm.name"></el-input>
	</el-form-item>
	<el-form-item label="创建者" prop="username">
		<el-input v-model="subjectForm.username"></el-input>
	</el-form-item>
	<el-form-item label="状态" prop="status">
		<el-select v-model="subjectForm.status" placeholder="请选择状态">
			<el-option label="启用" value="1"></el-option>
			<el-option label="禁用" value="0"></el-option>
		</el-select>
	</el-form-item>
	<el-form-item>
		<el-button type="primary" @click="search" @keyup.enter="search">搜索</el-button>
		<el-button @click="resetForm">清除</el-button>
		<el-button type="primary" icon="el-icon-plus" @click="addSubject">新增学科</el-button>
	</el-form-item>
</el-form>
```

```javascript
// 搜索学科
 search() {
   console.log('搜索表单：', this.subjectForm)
   this.subjectForm.page = 1
   this.getSubjectList()
 },
 // 清除按钮
 resetForm() {
   // 重置表单
   // TODO:重置表单必须需要加prop
   this.$refs.subjectRef.resetFields()
   this.getSubjectList()
},
```

2. 注意：
   1. 通过**prop**设置关联数据，无论是否进行表单验证；
   2. 筛选之后数据改变，返回到第一页再获取数据，否则中间的数据会被筛掉

### 点击删除

​	点击删除弹出提示框，确认之后就删除数据。

1. 步骤：
   1. 导入删除接口**subjectRemove**
   2. 为删除按钮绑定点击事件
   3. 传入当前**这一行**的数据
   4. 弹框提示用户：
      1. 取消：弹出取消删除提示；
      2. 确认：
         1. 调用接口删除数据
         2. 删除陈工之后，提示用户，重新获取数据即可

```javascript
// 删除学科
async removeSubject(row) {
  let confirmRes = await this.$confirm('此操作将永久删除该学科, 是否继续?', '提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  }).catch(err => err)
  if (confirmRes === 'confirm') {
    subjectRemove(row.id).then(res => {
      if (res.code !== 200) {
        return this.$message.warning('删除失败')
      }
      // TODO: 判断当前页数据是否为1，是-->跳转上一页，否不用跳，当前页是第一页时，不同跳转上一页
      if (this.subjectList.length === 1) {
        this.subjectForm.page--
        this.subjectForm.page = this.subjectForm.page === 0 ? 1 : this.subjectForm.page
      }
      this.$message.success('删除成功')
      this.getSubjectList()
    })
  } else {
    this.$message.info('删除已取消')
  }
},
```

2. 注意：
   1. 点击事件传参用到了**slot-scope**，建议将当前行的数据携带下来；
   2. 在删除成功之后需要对当前页数据的判断，若当前页删除之后数据没有了，那么跳转到上一页

### 进入修改

​	修改逻辑分为两步，弹出修改框，保存修改

1. 步骤：
   1. 新创建`editSubject.vue`子组件，并通过父组件的布尔值控制对话框的显示和隐藏
   2. 在点击编辑按钮时，显示对话框，并且将这一行的数据设置给编辑表单

2. 注意：
   1. 数据赋值时若是直接应用会出现修改对话框中内容页面同步更新的问题，使用深拷贝

```javascript
// 编辑学科
editSubject(row) {
  this.editDlVisible = true
  this.$refs.editSubjectRef.editSubjectForm = JSON.parse(JSON.stringify(row))
},
```

### 保存修改

​	进入编辑状态后，点击保存修改将数据提交到服务器，页面重新获取数据即可

1. 步骤：
   1. 为确定按钮绑定点击事件；
   2. 提交数据去服务器
   3. 修改成功之后
      1. 关闭对话框
      2. 重新获取数据

2. 注意：
   1. 修改成功之后不需要重置表单，因为再次点击编辑会重新设置数据

### git记录

```bash
git add .
git commit -m "学科模块--学科模块功能完成"
git checkout master
git merge subject
git branch -d suject
```

## 09-企业列表模块

### 创建**enterprise**分支

```bash
# 创建企业分支
git branch enterprise
# 切换到企业分支
git checkout enterprise
```

### 页面布局

1. 步骤

1. 1. 使用**element-ui卡片**把上下的布局弄好

1. 1. 在上面的容器中使用**element-ui**行内表单设置结构

1. 1. 在下面的容器中使用**element-ui**的**table**来设置

1. 1. 对于table内部的按钮，需要使用自定义列模板才能够使用

1. 1. 在底部的**table**下面使用**分页**实现分页效果

2. 注意

1. 1. 自定义列模板中使用的语法是Vue提供的**插槽**

1. 2. **表单、表格、分页**都需要绑定对应的数据，否则会有错误提示

### 初始数据获取

​	一进入页面应该抓取初始数据。

1. 步骤：

1. 1. 导入`@/api/enterprise.js`中的列表接口
   2. **created**中获取数据
   3. 设置给**table**的数据源
   4. **data**中增加总页数，并且为其赋值
   5. **总页数**设置给分页组件
   6. 调整**table**表头的属性，使之与数据相对应

```javascript
methods: {
  // 声明请求企业列表数据函数
  getEnterpriseList() {
    enterpriseList(this.enterPriseForm).then(res => {
      console.log('企业列表：', res)
      if (res.code === 200) {
        this.enterPriseList = res.data.items
        this.total = res.data.pagination.total
      }
    })
  }
},
created() {
   this.getEnterpriseList()
 }
```

2. 注意：

1. 1. 这部分数据的获取不需要任何的筛选条件，服务器有默认值

1. 2. 创建时间的格式如果想要想要调整，可以使用过滤器来实现

1. 3. **table**内部的内容修改需要通过**slot-scope**来进行自定义

### 数据分页

​	参考**学科列表**的数据分页

```javascript
// 分页-页码尺寸改变时触发
handleSizeChange(newSize) {
  this.enterPriseForm.limit = newSize
  this.getEnterpriseList()
},
// 分页-当前页码改变时触发
handleCurrentChange(newPage) {
  this.enterPriseForm.page = newPage
  this.getEnterpriseList()
}
```

### 数据新增

​		参考**学科列表**的数据新增

```javascript
// 确定新增企业
ensureAdd() {
  this.$refs.addEnterpriseRef.validate(valid => {
    if (!valid) {
      return this.$message.warning('请填写完整企业信息')
    }
    enterpriseAdd(this.addEnterpriseForm).then(res => {
      console.log('添加企业：', res)
      if (res.code === 200) {
        this.$parent.addDlVisible = false
        this.$message.success('企业新增成功')
        this.$parent.getEnterpriseList()
        this.$refs.addEnterpriseRef.resetFields()
      } else if (res.code === 201) {
        return this.$message.warning('企业编号已存在')
      } else {
        return this.$message.error('新增企业失败')
      }
    })
  })
}
```

### 状态修改

​	参考**学科列表**的状态修改

```html
<el-table-column label="状态">
  <template slot-scope="scope">
    <span v-if="scope.row.status===1">启用</span>
    <span v-else class="forbidden">禁用</span>
  </template>
</el-table-column>
<el-table-column label="操作">
  <template slot-scope="scope">
    <el-button type="text" @click="editEnterprise(scope.row)">编辑</el-button>
    <el-button
      type="text"
      @click="changeStatus(scope.row)"
    >{{scope.row.status===0?'启用':'禁用'}}</el-button>
    <el-button type="text" @click="removeEnterprise(scope.row)">删除</el-button>
  </template>
</el-table-column>
```

```javascript
// 修改企业状态
  changeStatus(row) {
    enterpriseStatus(row.id).then(res => {
      console.log('企业状态修改：', res)
      if (res.code === 200) {
        this.$message.success('状态修改成功')
        this.getEnterpriseList()
      } else {
        return this.$message.error('状态修改失败')
      }
    })
  },
```



### 数据筛选

参考**学科列表**的数据筛选

```html
<el-form :inline="true" :model="enterPriseForm" class="demo-form-inline" ref="enterPriseRef">
	<el-form-item label="企业编号" prop="eid">
	  <el-input v-model="enterPriseForm.eid"></el-input>
	</el-form-item>
	<el-form-item label="企业名称" prop="name">
	  <el-input v-model="enterPriseForm.name"></el-input>
	</el-form-item>
	<el-form-item label="创建者" prop="username">
	  <el-input v-model="enterPriseForm.username"></el-input>
	</el-form-item>
	<el-form-item label="状态" prop="status">
	  <el-select v-model="enterPriseForm.status" placeholder="请选择状态">
	    <el-option label="启用" :value="1"></el-option>
	    <el-option label="禁用" :value="0"></el-option>
	  </el-select>
	</el-form-item>
	<el-form-item>
	  <el-button type="primary" @click="search" @keyup.enter="search">搜索</el-button>
	  <el-button @click="resetForm">清除</el-button>
	  <el-button type="primary" icon="el-icon-plus" @click="addEnterPrise">新增企业</el-button>
	</el-form-item>
</el-form>
```

```javascript
 // 搜索
 search() {
   // 跳转到页码1
   this.enterPriseForm.page = 1
   this.getEnterpriseList()
 },
 // 清除
 resetForm() {
   this.$refs.enterPriseRef.resetFields()
   this.getEnterpriseList()
},
```

### 点击删除

参考**学科列表**删除

```javascript
// 删除企业
async removeEnterprise(row) {
  let confirmRes = await this.$confirm('此操作将永久删除该企业, 是否继续?', '提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  }).catch(err => err)
  if (confirmRes === 'confirm') {
    enterpriseRemove(row.id).then(res => {
      console.log('删除企业：', res)
      if (res.code === 200) {
        // TODO:判断当前页中数据，若数据为1，删完当前页无数据，跳转前一页，若数据大于1，删完后无须跳转前一页，当当前页处于第一页时，删完后无数据让页码强制为1
        if (this.enterPriseList.length === 1) {
          this.enterPriseForm.page--
          this.enterPriseForm.page = this.enterPriseForm.page === 0 ? 1 : this.enterPriseForm.page
        }
        this.$message.success('删除成功')
        this.getEnterpriseList()
      } else {
        return this.$message.error('删除失败')
      }
    })
  } else {
    return this.$message.info('已取消删除企业')
  }
},
```

### 进入修改&&保存修改

​	参考**学科列表**进入修改

```html
<template>
  <div class="edit-enterprise">
    <el-dialog center title="编辑企业" :visible.sync="$parent.editDlVisible" :before-close="cancalEdit">
      <el-form
        ref="editEnterpriseRef"
        :rules="editEnterpriseRul"
        :model="editEnterpriseForm"
        label-width="80px">
        <el-form-item label="企业编号" prop="eid">
          <el-input disabled v-model="editEnterpriseForm.eid"></el-input>
        </el-form-item>
        <el-form-item label="企业名称" prop="name">
          <el-input v-model="editEnterpriseForm.name"></el-input>
        </el-form-item>
        <el-form-item label="企业简称" prop="short_name">
          <el-input v-model="editEnterpriseForm.short_name"></el-input>
        </el-form-item>
        <el-form-item label="企业简介" prop="intro">
          <el-input type="textarea" v-model="editEnterpriseForm.intro"></el-input>
        </el-form-item>
        <el-form-item label="企业备注" prop="remark">
          <el-input v-model="editEnterpriseForm.remark"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="cancalEdit">取 消</el-button>
        <el-button type="primary" @click="submitEdit">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
import { enterpriseEdit } from '@/api/enterprise.js'
export default {
  name: 'edit-enterprise',
  data() {
    return {
      // 编辑企业表单对象
      editEnterpriseForm: {},
      //   编辑企业表单验证规则
      editEnterpriseRul: {
        eid: [{ required: true }],
        name: [{ required: true, message: '请输入企业名称', trigger: 'blur' }]
      }
    }
  },
  methods: {
    // 取消编辑企业
    cancalEdit() {
      this.$parent.editDlVisible = false
      this.$refs.editEnterpriseRef.resetFields()
    },
    // 确定编辑企业
    submitEdit() {
      this.$refs.editEnterpriseRef.validate(valid => {
        if (!valid) {
          return this.$message.warning('请完善企业信息')
        }
        enterpriseEdit(this.editEnterpriseForm).then(res => {
          console.log('编辑企业返回结果：', res)
          if (res.code === 200) {
            this.$message.success('企业信息修改成功')
            this.$parent.editDlVisible = false
            this.$parent.getEnterpriseList()
          } else {
            return this.$message.error('企业信息修改失败')
          }
        })
      })
    }
  }
}
</script>

<style lang="less">
.edit-enterprise {
  .el-dialog {
    width: 600px;
    height: 508px;
  }
}
</style>
```

###git记录

```bash
git add .
git commit -m"企业模块--企业模块功能完成"
git checkout master
git merge enterprise
git branch -d enterprise
```

## 10-用户列表模块

### 创建**user**分支

```bash
git branch user
git checkout user
```

### 页面布局

​	参考**学科列表**

```html
<template>
  <div class="user-container">
    <!--头部 卡片区域 -->
    <el-card>
      <el-form :inline="true" :model="userForm" class="demo-form-inline" ref="userRef">
        <el-form-item label="用户名称" prop="username">
          <el-input v-model="userForm.username"></el-input>
        </el-form-item>
        <el-form-item label="用户邮箱" prop="email">
          <el-input v-model="userForm.email"></el-input>
        </el-form-item>
        <el-form-item label="角色" prop="role_id">
          <el-select v-model="userForm.role_id" placeholder="请选择角色">
            <el-option label="管理员" value="2">管理员</el-option>
            <el-option label="老师" value="3">老师</el-option>
            <el-option label="学生" value="4">学生</el-option>
          </el-select>
        </el-form-item>
        <el-form-item>
          <el-button type="primary" @click="search">搜索</el-button>
          <el-button @click="reset">清除</el-button>
          <el-button type="primary" icon="el-icon-plus" @click="addUser">新增用户</el-button>
        </el-form-item>
      </el-form>
    </el-card>
    <!-- 主体 卡片区域 -->
    <el-card class="card-main">
      <el-table :data="userList" style="width: 100%" border>
        <el-table-column type="index" label="序号"></el-table-column>
        <el-table-column prop="username" label="用户名" width="180"></el-table-column>
        <el-table-column prop="phone" label="电话" width="180"></el-table-column>
        <el-table-column prop="email" label="邮箱"></el-table-column>
        <el-table-column prop="role" label="角色"></el-table-column>
        <el-table-column prop="remark" label="备注"></el-table-column>
        <el-table-column label="状态">
          <template slot-scope="scope">
            <span v-if="scope.row.status === 1">启用</span>
            <span v-else class="forbidden">禁用</span>
          </template>
        </el-table-column>
        <el-table-column label="操作">
          <template slot-scope="scope">
            <template v-if="scope.row.role_id ===1">
              <el-button disabled type="text" @click="editUser(scope.row)">编辑</el-button>
              <el-button
                type="text"
                disabled
                @click="changeStatus(scope.row)"
              >{{scope.row.status===0?'启用':'禁用'}}</el-button>
              <el-button disabled type="text" @click="removeUser(scope.row)">删除</el-button>
            </template>
            <template v-else>
              <el-button type="text" @click="editUser(scope.row)">编辑</el-button>
              <el-button
                type="text"
                @click="changeStatus(scope.row)"
              >{{scope.row.status===0?'启用':'禁用'}}</el-button>
              <el-button type="text" @click="removeUser(scope.row)">删除</el-button>
            </template>
          </template>
        </el-table-column>
      </el-table>
      <!-- 分页区域 -->
      <el-pagination
        background
        @size-change="handleSizeChange"
        @current-change="handleCurrentChange"
        :current-page="userForm.page"
        :page-sizes="[5, 10, 15, 20]"
        :page-size="userForm.limit"
        layout="total, sizes, prev, pager, next, jumper"
        :total="total"
      ></el-pagination>
    </el-card>
    <!-- 新增用户对话框区域 -->
    <add-user></add-user>
    <!-- 编辑用户对话框区域 -->
    <edit-user ref="editUserRef"></edit-user>
  </div>
</template>
```

### 初始数据获取

​	参考**学科列表**的初始数据获取

```javascript
methods: {
  // 声明发送请求获取用户列表数据
  getUserList() {
    userList(this.userForm).then(res => {
      console.log('用户列表：', res)
      if (res.code === 200) {
        this.userList = res.data.items
        this.total = res.data.pagination.total
      }
    })
  }
}
created() {
  // 调用获取用户列表数据函数
  this.getUserList()
}
```

### 数据分页

​	参考**学科列表**的数据分页

```javascript
// 分页-页尺寸改变触发
handleSizeChange(newSize) {
  this.userForm.limit = newSize
  this.getUserList()
},
// 分页-页码改变触发
handleCurrentChange(newPage) {
  this.userForm.page = newPage
  this.getUserList()
}
```

### 数据新增

​	参考**学科列表**的数据新增

```html
<template>
  <div class="add-user">
    <el-dialog center title="新增用户" :visible.sync="$parent.addDlVisible" :before-close="cancelAdd">
      <el-form ref="addUserRef" :model="addUserForm" :rules="addUserRul" label-width="80px">
        <el-form-item label="用户名" prop="username">
          <el-input v-model="addUserForm.username"></el-input>
        </el-form-item>
        <el-form-item label="邮箱" prop="email">
          <el-input v-model="addUserForm.email"></el-input>
        </el-form-item>
        <el-form-item label="电话" prop="phone">
          <el-input v-model="addUserForm.phone"></el-input>
        </el-form-item>
        <el-form-item label="角色" prop="role_id">
          <el-select v-model="addUserForm.role_id" placeholder="请选择角色">
            <el-option label="管理员" :value="2"></el-option>
            <el-option label="老师" :value="3"></el-option>
            <el-option label="学生" :value="4"></el-option>
          </el-select>
        </el-form-item>
        <el-form-item label="状态" prop="status">
          <el-select v-model="addUserForm.status" placeholder="请选择状态">
            <el-option label="启用" :value="1"></el-option>
            <el-option label="禁用" :value="0"></el-option>
          </el-select>
        </el-form-item>
        <el-form-item label="用户备注" prop="remark">
          <el-input type="textarea" v-model="addUserForm.remark"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="cancelAdd">取 消</el-button>
        <el-button type="primary" @click="ensureAdd">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
import { userAdd } from '@/api/user.js'
import { phoneCheck, emailCheck } from '@/utils/validator.js'
export default {
  name: 'add-user',
  data() {
    return {
      // 添加用户表单
      addUserForm: {
        username: '',
        email: '',
        phone: '',
        role_id: '',
        status: '',
        remark: ''
      },
      // 新增用户表单规则验证
      addUserRul: {
        username: [{ required: true, message: '请输入用户名', trigger: 'blur' }],
        email: [{ required: true, message: '请输入邮箱', trigger: 'blur' }, { validator: emailCheck, trigger: 'change' }],
        phone: [{ required: true, message: '请输入手机号', trigger: 'blur' }, { validator: phoneCheck, trigger: 'change' }],
        role_id: [{ required: true, message: '请选择角色', trigger: 'blur' }]
      }
    }
  },
  methods: {
    // 确定添加用户
    ensureAdd() {
      this.$refs.addUserRef.validate(valid => {
        if (!valid) {
          return this.$message.warning('请完善新增用户必填项')
        }
        userAdd(this.addUserForm).then(res => {
          console.log('新增用户结果:', res)
          if (res.code === 200) {
            this.$message.success('新增用户成功')
            this.$parent.getUserList()
            this.$parent.addDlVisible = false
            this.$refs.addUserRef.resetFields()
          } else {
            return this.$message.error(res.message)
          }
        })
      })
    },
    // 取消添加用户
    cancelAdd() {
      this.$parent.addDlVisible = false
      this.$refs.addUserRef.resetFields()
    }
  }
}
</script>

<style lang="less">
.add-user {
  .el-dialog {
    width: 478px;
    height: 558px;
  }
}
</style>
```

### 状态修改

​	参考**学科列表**的状态修改

```html
<el-table-column label="状态">
	<template slot-scope="scope">
	    <span v-if="scope.row.status === 1">启用</span>
	    <span v-else class="forbidden">禁用</span>
	</template>
</el-table-column>
<el-table-column label="操作">
	<template slot-scope="scope">
		<template v-if="scope.row.role_id ===1">
			<el-button disabled type="text" @click="editUser(scope.row)">编辑</el-button>
			<el-button type="text" disabled @click="changeStatus(scope.row)">{{scope.row.status===0?'启用':'禁用'}}</el-button>
	      	<el-button disabled type="text" @click="removeUser(scope.row)">删除</el-button>
		</template>
		<template v-else>
			<el-button type="text" @click="editUser(scope.row)">编辑</el-button>
			<el-button type="text" @click="changeStatus(scope.row)">{{scope.row.status===0?'启用':'禁用'}}</el-button>
			<el-button type="text" @click="removeUser(scope.row)">删除</el-button>
		</template>
	</template>
</el-table-column>
```

```javascript
// 改变用户状态
changeStatus(row) {
  userStatus(row.id).then(res => {
    if (res.code === 200) {
      this.$message.success('状态修改成功')
      this.getUserList()
    } else {
      return this.$message.error('状态修改失败')
    }
  })
}
```

### 数据筛选

​	参考**学科列表**的数据筛选

```html
<el-form :inline="true" :model="userForm" class="demo-form-inline" ref="userRef">
	<el-form-item label="用户名称" prop="username">
	  <el-input v-model="userForm.username"></el-input>
	</el-form-item>
	<el-form-item label="用户邮箱" prop="email">
	  <el-input v-model="userForm.email"></el-input>
	</el-form-item>
	<el-form-item label="角色" prop="role_id">
	  <el-select v-model="userForm.role_id" placeholder="请选择角色">
	    <el-option label="管理员" value="2">管理员</el-option>
	    <el-option label="老师" value="3">老师</el-option>
	    <el-option label="学生" value="4">学生</el-option>
	  </el-select>
	</el-form-item>
	<el-form-item>
	  <el-button type="primary" @click="search">搜索</el-button>
	  <el-button @click="reset">清除</el-button>
	  <el-button type="primary" icon="el-icon-plus" @click="addUser">新增用户</el-button>
	</el-form-item>
</el-form>
```

```javascript
// 搜索按钮
 search() {
   this.userForm.page = 1
   this.getUserList()
 },
 // 清除按钮
 reset() {
   this.$refs.userRef.resetFields()
   this.getUserList()
 },
```

### 点击删除

​	参考**学科列表**的删除

```javascript
// 删除用户
async removeUser(row) {
  let confirmRes = await this.$confirm('是否永久删除该用户?', '提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  }).catch(err => err)
  if (confirmRes === 'confirm') {
    userRemove(row.id).then(res => {
      if (res.code === 200) {
        if (this.userList.length === 1) {
          this.userForm.page--
          this.userForm.page = this.userForm.page === 0 ? 1 : this.userForm.page
        }
        this.$message.success('删除用户成功')
        this.getUserList()
      } else {
        return this.$message.error('删除用户失败')
      }
    })
  } else {
    return this.$message.info('已取消删除用户')
  }
},
```

### 进入修改

​	参考**学科列表**的进入修改

1. 步骤：
   1. 新创建组件`addUser.vue`;
   2. 通过父组件的**布尔值**控制子组件对话框的显示与隐藏；
   3. 点击编辑按钮时，将这一行的数据设置给编辑表单；
   4. 数据赋值时若是直接引用赋值会出现修改对话框内容页面同步更新的问题，使用深拷贝。

### 保存修改

​	参考**学科列表**的保存修改

```javascript
// 确定编辑用户按钮
submitEdit() {
  this.$refs.editUserRef.validate(valid => {
    if (!valid) {
      return this.$message.warning('请完善用户信息')
    }
    userEdit(this.editUserForm).then(res => {
      console.log('编辑用户返回结果：', res)
      if (res.code === 200) {
        this.$message.success('修改成功')
        this.$parent.getUserList()
        this.$parent.editDlVisible = false
      }
    })
  })
}
```

### git记录

```bash
git add .
git commit -m "用户列表模块--用户列表模块功能完成"
git checkout master
git merge user
git branch -d user
```

## ==11-权限列表模块==

### 创建**power**分支

```bash
git branch power
git checkout power
```

### 权限是什么？

​	不同的用户登录到网站之后，能够看到的页面是不同的，能够操纵的功能也是不同的，权限其实就是用代码来实现这些功能的：

1. 两个词
   1. 用户：网站的用户可以有很多个，若针对性为每个人进行设置比较繁琐，故为了方便管理会使用角色方式进行管理。
   2. 角色：
      * 为了方便管理，大部分的项目会使用角色的方式进行管理
      * 用户注册--分配角色--判断角色
      * 这种做法，项目的用户有很多个，但是角色并不会很多
      * 这样就不需要判断用户，直接判断角色即可
      * 若希望更改用户的权限，那么修改用户对应的角色即可

2. 核心功能

   * 用户去不了
     * 不同角色能够访问的页面是不同

   * 用户看不到
     * 页面上只显示当前角色可以使用的功能
     * 比如：路由导航、操纵按钮

3. 角色权限
   * 不同角色能够访问的页面应该事前约定好
   * 不同角色能够操纵的功能也应该事前约定好

### 状态判断

​	用户信息中有个状态信息，若是禁用，应该什么页面也访问不到

1. 需求：
   * 用户登录完成之后，获取用户信息之后
   * 判断用户状态
     * 启用：继续访问
     * 禁用：打回登录页，并提示用户没有权限

2. 步骤：
   * `router/index.js`的导航守卫中增加判断逻辑
   * 判断逻辑需要写在用户拉取成功之后

### 路由访问权限

1. 路由元信息
   * 在路由上额外的保存信息，通过元信息来控制路由的访问权限

2. 允许访问的页面
   * 超级管理员：所有
   * 管理员：所有
   * 老师：除了**用户列表**
   * 学生：题库列表

3. 步骤：
   1. 在路由规则上配置允许访问的角色信息，数组；
   2. 在**导航守卫**中判断用户的角色和**路由元信息**进行匹配
      * 存在：放走
      * 不存在：提示用户

```javascript
/ 配置meta字段
export default [
  // 登录页
  {
    path: '/',
    redirect: '/login'
  },
  {
    path: '/login',
    component: login,
    meta: {
      roles: ['超级管理员', '管理员', '老师', '学生']
    }
  },
  // 首页
  {
    path: '/index',
    component: index,
    redirect: '/index/subject',
    // 嵌套路由
    children: [{
      // 数据概述
      path: '/index/chart',
      component: chart,
      meta: {
        title: '数据概述',
        icon: 'el-icon-pie-chart',
        fullPath: '/index/chart',
        roles: ['超级管理员', '管理员', '老师']
      }
    }, {
      // 用户列表
      path: '/index/user',
      component: user,
      meta: {
        title: '用户列表',
        icon: 'el-icon-user',
        fullPath: '/index/user',
        roles: ['超级管理员', '管理员']
      }
    }, {
      // 题库列表
      path: '/index/question',
      component: question,
      meta: {
        title: '题库列表',
        icon: 'el-icon-edit-outline',
        fullPath: '/index/question',
        roles: ['超级管理员', '管理员', '老师', '学生']
      }
    }, {
      // 企业列表
      path: '/index/enterprise',
      component: enterprise,
      meta: {
        title: '企业列表',
        icon: 'el-icon-notebook-2',
        fullPath: '/index/enterprise',
        roles: ['超级管理员', '管理员', '老师']
      }
    }, {
      // 学科列表
      path: '/index/subject',
      component: subject,
      meta: {
        title: '学科列表',
        icon: 'el-icon-office-building',
        fullPath: '/index/subject',
        roles: ['超级管理员', '管理员', '老师']
      }
    }]
  }
]
```

```javascript
// 声明路由白名单
let whitePaths = ['/login']
// 声明登录路由
const loginPath = '/login'
router.beforeEach((to, from, next) => {
  // 除了登录页不用判断是都有token，其他页面都需要判断是否有token-->无token跳转到登录页
  if (!whitePaths.includes(to.path)) {
    if (!getToken()) {
      Message.error('请先登录！')
      return next(loginPath)
    }
    // 判断登录后是否有用户信息-->无用户信息跳转到登录页
    if (!store.state.userInfo) {
      userinfo().then(res => {
        if (res.code === 206) {
          Message.error('请重新登录！')
          removeToken()
          return next(loginPath)
        } else {
          // 2.1 判断用户信息中的状态-->status为1表示禁用，跳转到登录页
          if (res.data.status === 0) {
            Message.warning('当前用户处于禁用状态，请联系管理员！')
            return next(loginPath)
          } else {
            // 用户头像缺少基地址
            res.data.avatar = `${process.env.VUE_APP_BASEURL}/${res.data.avatar}`
            // 处理用户的状态
            switch (res.data.role) {
              case '超级管理员':
                res.data.role_id = 1
                break
              case '管理员':
                res.data.role_id = 2
                break
              case '老师':
                res.data.role_id = 3
                break
              case '学生':
                res.data.role_id = 4
                break
            }
            // 将用户的信息保存到store中
            store.commit('setInfo', res.data)
            // 判断用户信息token验证成功
            console.log('Vuex中的数据', store.state.userInfo)
            console.log('角色', to.meta.roles)
            next()
          }
        }
      })
    } else {
      // 有用户信息，执行
      // 判断是否有权限访问
      // 判断元子段中是否有包含有这些角色
      if (to.meta.roles.includes(store.state.userInfo.role)) {
        next()
      } else {
        Message.warning('当前用户没有访问权限！')
      }
    }
  } else {
    next()
  }
})
```

### 路由显示权限

​	既然路由不能访问了，那为什么还要显示呢？

1. 步骤：
   1. 将路由规则抽取为独立的文件`router/routes.js`
   2. 在路由导入这个规则
   3. 首页的列表使用**v-for**来生成
   4. **v-for**和**v-if**结合使用会有错误提示，这是使用**template**进行包裹，这个标签不会生成，只是占位而已
   5. 在遍历的时候根据**路由元信息**和**用户信息**进行对比即可区分是否显示

```html
<el-menu :collapse="isCollapse" :default-active="$route.path" 
         class="el-menu-vertical-demo" router>
	<template v-for="(item, index) in routes[2].children">
		<el-menu-item 
         	v-if="item.meta.roles.includes($store.state.userInfo.role)"
			:index="item.meta.fullPath" :key="index">
			<i :class="item.meta.icon"></i>
			<span slot="title">{{item.meta.title}}</span>
		</el-menu-item>
	</template>
</el-menu>
```

### 功能级别权限

​	功能级别权限，即让用户看不到即可，通过用户信息和规则比对即可实现。

1. 步骤：
   1. 在希望增加判断的地方使用**v-if**指令，结合用户信息进行判断即可。

```html
<el-button type="text" 
	v-if="['超级管理员'].includes($store.state.userInfo.role)" 
     @click="removeSubject(scope.row)">删除
</el-button>
```

### 自定义指令优化

​	对于功能级别权限通过判断逻辑可以实现功能，但是如果大量重复的编写，会造成代码的冗余，我们可以通过自定义指令来优化这部分操作。

1. 步骤：
   1. 创建编写自定义指令文件`directives/directive.js`
   2. 导入**Vue**并创建自定义指令，导入**store**来获取用户信息
   3. 在自定义指令接口传入角色数组和用户信息进行比对，不符合移除元素即可

```javascript
// 添加自定义指令
import Vue from 'vue'
improt store from '@/store/index.js'

// 注册自定义指令
Vue.directive('power', {
    instered: (el, bind) => {
      if (!bind.value.includes(store.statue.userInfo.role)) {
          // 若存在，不做处理
          // 若存在，移除这个元素
          el.parentNode.removeChild(el)
      }  
    }
})
```

```html
<!-- 使用自定义指令，传入能够使用的角色即可 -->
<el-button type="text" v-power="['超级管理员']" @click="removeSubject(scope.row)">
  删除
</el-button>
```

### git记录

```bash
git add .
git commit -m "权限模块-完成权限模块功能"
git checkout master
git merge
git branch -d power
```

## 12-题库列表模块

### 创建**question**分支

```
git branch question
git checkout question
```

### 页面布局

```html
<template>
  <div class="question-container">
    <!-- 头部 卡片区域 -->
    <el-card>
      <el-form :inline="true" ref="questionRef" :model="questionForm" class="demo-form-inline">
        <el-row>
          <el-col>
            <el-form-item label="学科" prop="subject">
              <el-select v-model="questionForm.subject" placeholder="请选择学科">
                <el-option
                  v-for="(item, index) in subjectData"
                  :key="index"
                  :label="item.name"
                  :value="item.id"
                ></el-option>
              </el-select>
            </el-form-item>
            <el-form-item label="阶段" prop="step">
              <el-select v-model="questionForm.step" placeholder="请选择阶段">
                <el-option label="初级" :value="1"></el-option>
                <el-option label="中级" :value="2"></el-option>
                <el-option label="高级" :value="3"></el-option>
              </el-select>
            </el-form-item>
            <el-form-item label="企业" prop="enterprise">
              <el-select v-model="questionForm.enterprise" placeholder="请选择企业">
                <el-option
                  v-for="(item, index) in enterpriseData"
                  :key="index"
                  :label="item.name"
                  :value="item.id"
                ></el-option>
              </el-select>
            </el-form-item>
            <el-form-item label="题型" prop="type">
              <el-select v-model="questionForm.type" placeholder="请选择题型">
                <el-option label="单选" :value="1"></el-option>
                <el-option label="多选" :value="2"></el-option>
                <el-option label="简单" :value="3"></el-option>
              </el-select>
            </el-form-item>
          </el-col>
        </el-row>
        <el-row>
          <el-col>
            <el-form-item label="难度" prop="difficulty">
              <el-select v-model="questionForm.difficulty" placeholder="请选择难度">
                <el-option label="简单" value="1"></el-option>
                <el-option label="一般" value="2"></el-option>
                <el-option label="困难" value="3"></el-option>
              </el-select>
            </el-form-item>
            <el-form-item label="作者" prop="username">
              <el-input v-model="questionForm.username"></el-input>
            </el-form-item>
            <el-form-item label="状态" prop="status">
              <el-select v-model="questionForm.status" placeholder="请选择状态">
                <el-option label="启用" value="1"></el-option>
                <el-option label="禁用" value="0"></el-option>
              </el-select>
            </el-form-item>
            <el-form-item label="日期" prop="create_date">
              <el-date-picker v-model="questionForm.create_date" type="date" placeholder="选择日期"></el-date-picker>
            </el-form-item>
          </el-col>
        </el-row>
        <el-row>
          <el-col>
            <el-form-item label="标题" prop="title">
              <el-input class="input-title" v-model="questionForm.title"></el-input>
            </el-form-item>
            <el-form-item>
              <el-button type="primary" @click="search">搜索</el-button>
              <el-button @click="reset">清除</el-button>
              <el-button type="primary" icon="el-icon-plus" @click="addQuestionBtn">新增试题</el-button>
            </el-form-item>
          </el-col>
        </el-row>
      </el-form>
    </el-card>
    <!-- 主体 卡片区域 -->
    <el-card class="card-main">
      <el-table :data="questionData" style="width: 100%" border>
        <el-table-column type="index" label="序号" width="100"></el-table-column>
        <el-table-column prop="title" label="题目" width="180">
          <template slot-scope="scope">
            <span v-html="scope.row.title"></span>
          </template>
        </el-table-column>
        <el-table-column label="学科、阶段" width="180">
          <template slot-scope="scope">
            <span>{{scope.row.subject_name + '.' + {1: '初级', 2: '中级', 3: '高级'}[scope.row.step]}}</span>
          </template>
        </el-table-column>
        <el-table-column label="题型">
          <template slot-scope="scope">
            <span>{{{1: '单选', 2: '多选', 3: '简答'}[scope.row.type]}}</span>
          </template>
        </el-table-column>
        <el-table-column prop="enterprise_name" label="企业"></el-table-column>
        <el-table-column prop="username" label="创建者"></el-table-column>
        <el-table-column label="状态">
          <template slot-scope="scope">
            <span v-if="scope.row.status===1">启用</span>
            <span v-else class="forbidden">禁用</span>
          </template>
        </el-table-column>
        <el-table-column prop="reads" label="访问量"></el-table-column>
        <el-table-column label="操作">
          <template slot-scope="scope">
            <el-button type="text" @click="editQuestion(scope.row)">编辑</el-button>
            <el-button
              type="text"
              @click="changeStatus(scope.row)"
            >{{scope.row.status===1?'启用':'禁用'}}</el-button>
            <el-button type="text" @click="removeQuestion(scope.row)">删除</el-button>
          </template>
        </el-table-column>
      </el-table>
      <!-- 分页区域 -->
      <el-pagination
        background
        @size-change="handleSizeChange"
        @current-change="handleCurrentChange"
        :current-page="questionForm.page"
        :page-sizes="[5, 10, 16, 22]"
        :page-size="questionForm.limit"
        layout="total, sizes, prev, pager, next, jumper"
        :total="total"
      ></el-pagination>
    </el-card>
    <!-- 新增试题对话框组件 -->
    <add-question></add-question>
    <!-- 编辑试题对话框组件 -->
    <edit-qeustion ref="editQuestionRef"></edit-qeustion>
  </div>
</template>
```

### 初始数据获取

​	参考**学科列表**

```javascript
methods: {
// 声明发送请求获取学科数据函数
    getSubjectList() {
      subjectList().then(res => {
        console.log('试题列表获取学科数据：', res)
        if (res.code === 200) {
          this.subjectData = res.data.items
        } else {
          return this.$message.error('获取学科数据列表失败！')
        }
      })
    },
    // 声明发送请求获取企业数据函数
    getEnterpriseList() {
      enterpriseList().then(res => {
        console.log('试题列表中企业数据：', res)
        if (res.code === 200) {
          this.enterpriseData = res.data.items
        }
      })
    },
    // 声明发送请求题库数据函数
    getQuestionList() {
      questionList(this.questionForm).then(res => {
        console.log('题库列表', res)
        if (res.code === 200) {
          this.questionData = res.data.items
          this.total = res.data.pagination.total
        } else {
          return this.$message.error('获取题库列表失败')
        }
      })
    }
  },
created() {
  // 调用学科请求数据函数
  this.getSubjectList()
  // 调用企业请求数据函数
  this.getEnterpriseList()
  // 调用题库请求数据函数
  this.getQuestionList()
}
```

### 数据分页

​	参考**学科列表**数据分页

### 数据新增

1. 步骤：
   1. 新创建子组件`addQuestion.vue`
   2. 通过父组件**布尔值**控制对话框显示或者隐藏
   3. 调整表单结构
   4. 绑定表单数据
   5. 整合表单验证
   6. 点击提交进行表单验证
      1. 错误：提示题库
      2. 正确：调用接口提交数据
         1. 重置表单
         2. 关闭对话框
         3. 重新获取数据

2. 注意：必须的字段根据接口文档来设置

### 状态修改

​	参考**学科列表**的状态修改

### 数据筛选

​	参考**学科列表**的数据筛选

### 点击删除

​	参考**学科列表**的删除

### 新增框--全屏对话框

* 步骤
  1. 整合对话框到`question.vue`页面中
  2. 设置**fullscreen**让对话框全屏
  3. 页面中的元素分分割线通过**divider**来实现
  4. 内容的输入通过表达来设置

### 新增框--vue-quill-editor编辑器

​	网址： https://www.npmjs.com/package/vue-quill-editor 

```html
<!-- 试题标题区域 -->
<el-form-item label="试题标题" prop="title"></el-form-item>
<quill-editor v-model="addQuestionForm.title"></quill-editor>
```

### 新增框-单选区域

* 步骤：
  1. 整体使用**el-radio-group**标签进行包裹
  2. 每一项用**div**包裹，依次包含**el-radio、el-input、el-upload**
  3. 通过样式设置外观
  4. 设置上传的地址**process.env.VUE_APP_BASEURL+接口地址**
  5. 绑定上传的事件

```html
<!-- 单选区域 -->
<el-form-item v-if="addQuestionForm.type === '1'" label="单选" prop="single_select_answer">
  <el-radio-group v-model="addQuestionForm.single_select_answer">
    C
    <div class="raido-box">
      <el-radio label="A">A</el-radio>
      <el-input v-model="addQuestionForm.select_options[0].text"></el-input>
      <el-upload
        class="avatar-uploader"
        :action="uploadAction"
        :show-file-list="false"
        :on-success="handleASuccess"
        :before-upload="beforeAvatarUpload">
        <img v-if="imageAUrl" :src="imageAUrl" class="avatar" />
        <i v-else class="el-icon-plus avatar-uploader-icon"></i>
      </el-upload>
    </div>
    <div class="raido-box">
      <el-radio label="B">B</el-radio>
      <el-input v-model="addQuestionForm.select_options[1].text"></el-input>
      <el-upload
        class="avatar-uploader"
        :action="uploadAction"
        :show-file-list="false"
        :on-success="handleBSuccess"
        :before-upload="beforeAvatarUpload">
        <img v-if="imageBUrl" :src="imageBUrl" class="avatar" />
        <i v-else class="el-icon-plus avatar-uploader-icon"></i>
      </el-upload>
    </div>
    <div class="raido-box">
      <el-radio label="C">C</el-radio>
      <el-input v-model="addQuestionForm.select_options[2].text"></el-input>
      <el-upload
        class="avatar-uploader"
        :action="uploadAction"
        :show-file-list="false"
        :on-success="handleCSuccess"
        :before-upload="beforeAvatarUpload">
        <img v-if="imageCUrl" :src="imageCUrl" class="avatar" />
        <i v-else class="el-icon-plus avatar-uploader-icon"></i>
      </el-upload>
    </div>
    <div class="raido-box">
      <el-radio label="D">D</el-radio>
      <el-input v-model="addQuestionForm.select_options[3].text"></el-input>
      <el-upload
        class="avatar-uploader"
        :action="uploadAction"
        :show-file-list="false"
        :on-success="handleDSuccess"
        :before-upload="beforeAvatarUpload">
        <img v-if="imageDUrl" :src="imageDUrl" class="avatar" />
        <i v-else class="el-icon-plus avatar-uploader-icon"></i>
      </el-upload>
    </div>
  </el-radio-group>
</el-form-item>
```

```javascript
// 单选区域图像上传成功触发
handleASuccess(res, file) {
  this.imageAUrl = URL.createObjectURL(file.raw)
  this.addQuestionForm.select_options[0].image = res.data.url
},
handleBSuccess(res, file) {
  this.imageBUrl = URL.createObjectURL(file.raw)
  this.addQuestionForm.select_options[1].image = res.data.url
},
handleCSuccess(res, file) {
  this.imageCUrl = URL.createObjectURL(file.raw)
  this.addQuestionForm.select_options[2].image = res.data.url
},
handleDSuccess(res, file) {
  this.imageDUrl = URL.createObjectURL(file.raw)
  this.addQuestionForm.select_options[3].image = res.data.url
},
// 单选区域图像上传之前触发
beforeAvatarUpload(file) {
  let isJPG = file.type === 'image/jpeg'
  let isLt2M = file.size / 1024 / 1024 < 2
  if (!isJPG) {
    this.$message.error('上传图片介绍只能是JPG格式')
  }
  if (!isLt2M) {
    this.$message.error('上传图片介绍大小不能超过2MB！')
  }
  return isJPG && isLt2M
},
```

### 新增框-多选区域

​	单选和多选的选项十分的类似，但并不能通过一个**element-ui**组件来实现，这里需要组合几个组件才可以

```html
<!-- 多选区域 -->
  <el-form-item
    v-else-if="addQuestionForm.type === '2'"
    label="多选"
    prop="multiple_select_answer">
    <el-checkbox-group v-model="addQuestionForm.multiple_select_answer">
      <div class="raido-box">
        <el-checkbox label="A">A</el-checkbox>
        <el-input v-model="addQuestionForm.select_options[0].text"></el-input>
        <el-upload
          class="avatar-uploader"
          :action="uploadAction"
          :show-file-list="false"
          :on-success="handleASuccess"
          :before-upload="beforeAvatarUpload">
          <img v-if="imageAUrl" :src="imageAUrl" class="avatar" />
          <i v-else class="el-icon-plus avatar-uploader-icon"></i>
        </el-upload>
      </div>
      <div class="raido-box checkbox-radio">
        <el-checkbox label="B">B</el-checkbox>
        <el-input v-model="addQuestionForm.select_options[1].text"></el-input>
        <el-upload
          class="avatar-uploader"
          :action="uploadAction"
          :show-file-list="false"
          :on-success="handleBSuccess"
          :before-upload="beforeAvatarUpload">
          <img v-if="imageBUrl" :src="imageBUrl" class="avatar" />
          <i v-else class="el-icon-plus avatar-uploader-icon"></i>
        </el-upload>
      </div>
      <div class="raido-box checkbox-radio">
        <el-checkbox label="C">C</el-checkbox>
        <el-input v-model="addQuestionForm.select_options[2].text"></el-input>
        <el-upload
          class="avatar-uploader"
          :action="uploadAction"
          :show-file-list="false"
          :on-success="handleCSuccess"
          :before-upload="beforeAvatarUpload">
          <img v-if="imageCUrl" :src="imageCUrl" class="avatar" />
          <i v-else class="el-icon-plus avatar-uploader-icon"></i>
        </el-upload>
      </div>
      <div class="raido-box checkbox-radio">
        <el-checkbox label="D">D</el-checkbox>
        <el-input v-model="addQuestionForm.select_options[3].text"></el-input>
        <el-upload
          class="avatar-uploader"
          :action="uploadAction"
          :show-file-list="false"
          :on-success="handleDSuccess"
          :before-upload="beforeAvatarUpload">
          <img v-if="imageDUrl" :src="imageDUrl" class="avatar" />
          <i v-else class="el-icon-plus avatar-uploader-icon"></i>
        </el-upload>
      </div>
    </el-checkbox-group>
  </el-form-item>
```

### 新增框-简单题

​	简单题输入框就是一个文本域，复杂度比单选和多选要低，但是在切换的时候需要和题库类型关联

1. 步骤：
   1. 通过**el-input**来设置输入区域
   2. 设置**type**为**textarea**将其设置为文本域
   3. 单选，多选，简单需要根据顶部的选项进行联动
   4. 选择**v-if**和属性绑定即可

```html
<el-form-item label="题型" prop="type">
	<el-radio-group v-model="addQuestionForm.type">
	  <el-radio label="1">单选</el-radio>
	  <el-radio label="2">多选</el-radio>
	  <el-radio label="3">简答</el-radio>
	</el-radio-group>
</el-form-item>

<el-form-item label="单选" v-if="form.type === '1'">内容略</el-form-item>
<el-form-item label="多选" v-if="form.type === '2'">内容略</el-form-item>
<el-form-item label="简答" v-if="form.type === '3'">内容略</el-form-item>
```

2. 注意：三个区域的显示与隐藏依赖于题目的类型，通过**v-if**控制

### 新增框-数据提交

1. 步骤
   1. 整合表单验证
   2. **prop**设置绑定的数据
   3. 点击提交进行验证
      1. 错误：提示用户
      2. 正确：
         1. 清空表单
         2. 将图片预览地址清空
         3. 关闭对话框
         4. 重新获取数据

```javascript
// 确定新增试题
ensureAdd() {
  this.$refs.addQuestionRef.validate(valid => {
    if (!valid) {
      return this.$message.warning('请完善试题信息')
    } else {
      questionAdd(this.addQuestionForm).then(res => {
        console.log('新增表单成功', res)
        if (res.code === 200) {
          this.$message.success('新增试题成功！')
          this.$parent.getQuestionList()
          this.$parent.addDlvisible = false
          this.$refs.addQuestionRef.resetFields()
          // 预览地址清空
          this.imageAUrl = ''
          this.imageBUrl = ''
          this.imageCUrl = ''
          this.imageDUrl = ''
          this.videoUrl = ''
          this.isShowVideo = false
        } else {
          return this.$message.error('新增试题失败')
        }
      })
    }
  })
}
```

### 进入修改

​	修改的逻辑分为两步，弹出修改框，以及保存修改。

1. 步骤：
   1. 新创建子组件**editQuestion**
   2. 页面整合**dialog**，并在内部增加表单及对应规则；
   3. 这部分和新增框基本一样，直接修改即可
   4. 在点击编辑按钮时，通过父组件**布尔值**控制显示或者隐藏，并将这一行的数据设置给编辑表单
   5. 图片的预览地址服务器返回的在线地址，需要我们手动进行处理
   6. 选项的顺序是紊乱的，需要进行重新排序

```javascript
// 编辑题库按钮
editQuestion(row) {
  this.editDlvisible = true
  let editForm = JSON.parse(JSON.stringify(row))
  // 多选项需要传入一个数组，因返回的多选中是一个字符串，需转换为数组
  editForm.multiple_select_answer = editForm.multiple_select_answer.split(',').filter(item => {
    return item !== ''
  })
  // 城市也是需要传入一个数组，返回的城市是一个字符串，需转换为数组
  editForm.city = editForm.city.split(',')
  // 处理选项的顺序
  let selectOptions = []
  editForm.select_options.forEach(item => {
    switch (item.label) {
      case 'A':
        selectOptions[0] = item
        break
      case 'B':
        selectOptions[1] = item
        break
      case 'C':
        selectOptions[2] = item
        break
      case 'D':
        selectOptions[3] = item
        break
    }
  })
  editForm.select_options = selectOptions
  this.$refs.editQuestionRef.editQuestionForm = editForm
}
```

```javascript
// 打开对话框动画结束的回调
opened() {
  // 处理图片路径
  let imageUrl = this.editQuestionForm.select_options.map(item => {
    return item.image.trim() === '' ? '' : process.env.VUE_APP_BASEURL + '/' + item.image
  })
  console.log('编辑后现有的数据', this.editQuestionForm)
  this.imageAUrl = imageUrl[0]
  this.imageBUrl = imageUrl[1]
  this.imageCUrl = imageUrl[2]
  this.imageDUrl = imageUrl[3]
  if (this.editQuestionForm.video) {
    this.isShowVideo = true
    this.videoUrl = process.env.VUE_APP_BASEURL + '/' + this.editQuestionForm.video
  }
},
```

2. 注意：
   1. 编辑的数据需要进行深拷贝
   2. 使用对话框回调函数**opened**，打开对话框动画结束的回调函数

### 保存修改

​	进入编辑状态之后，点击保存修改将数据提交到服务器，页面重新获取数据即可

### git记录

```bash
git add .
git commit -m "题库列表模块--新增、修改试题功能完成"
git checkout master
git merge question
git branch -d question
```

## 13-数据概述模块

### 创建**chart**分支

```bash
git branch chart
git checkout chart
```

### 页面布局

1. 步骤：
   1. 使用**element-ui**的**卡片**将上下布局整好
   2. 上面使用**border-radius=50%**设置内容
   3. 下面使用**Echarts**实现饼状图

```html
<template>
  <div class="chart-container">
    <el-card class="chart-header">
      <ul class="circle-box">
        <li class="circle-item">
          <div class="circle primary">{{dataTitle.increment_users}}</div>
          <span>今日新增用户</span>
        </li>
        <li class="circle-item">
          <div class="circle primary">{{0}}</div>
          <span>用户总量</span>
        </li>
        <li class="circle-item">
          <div class="circle warning">{{dataTitle.total_users}}</div>
          <span>新增试题</span>
        </li>
        <li class="circle-item">
          <div class="circle warning">{{dataTitle.total_questions}}</div>
          <span>总试题量</span>
        </li>
        <li class="circle-item">
          <div class="circle success">{{dataTitle.total_done_questions}}</div>
          <span>总刷题量</span>
        </li>
        <li class="circle-item">
          <div class="circle success">{{dataTitle.personal_questions}}</div>
          <span>人均刷题量</span>
        </li>
      </ul>
    </el-card>
    <el-card class="chart-main">
      <div class="main"></div>
    </el-card>
  </div>
</template>
```

```javascript
<script>
import echarts from 'echarts'
import { dataTitle, dataEnterprise } from '@/api/chart.js'
export default {
  name: 'chart',
  data() {
    return {
      // 面板数据列表
      dataTitle: {}
    }
  },
  methods: {
    // 声明发送获取面板数据
    getDataTitle() {
      dataTitle().then(res => {
        if (res.code === 200) {
          this.dataTitle = res.data
        } else {
          return this.$message.warning(res.message)
        }
      })
    },
    // 声明发送获取企业题目统计数据
    getDataEnterprise() {
      dataEnterprise().then(res => {
        // 企业题目统计数据
        let enterpriseList = []
        // 企业题目名称
        let enterpriseName = []
        if (res.code === 200) {
          enterpriseList = res.data
          res.data.forEach(item => {
            enterpriseName.push(item.name)
          })
        }
        // 基于准备好的dom，初始化echarts实例
        let myChart = echarts.init(document.querySelector('.main'))
        let option = {
          title: {
            text: '整体数据',
            left: 'left'
          },
          tooltip: {
            trigger: 'item',
            formatter: '{a} <br/>{b}: {c} ({d}%)'
          },
          legend: {
            orient: 'vertical',
            right: 10,
            data: enterpriseName
          },
          series: [
            {
              name: '访问来源',
              type: 'pie',
              radius: ['50%', '70%'],
              avoidLabelOverlap: false,
              color: ['#f76137', '#f9b358', '#409eff', '#68a132', '#55CD78'],
              label: {
                normal: {
                  show: false,
                  position: 'center'
                },
                emphasis: {
                  show: true,
                  textStyle: {
                    fontSize: '30',
                    fontWeight: 'bold'
                  }
                }
              },
              labelLine: {
                normal: {
                  show: false
                }
              },
              data: enterpriseList
            }
          ]
        }
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option)
      })
    }
  },
  created() {
    // 调用数据面板获取面板数据函数
    this.getDataTitle()
    this.$nextTick(() => {
      // 调用企业题目统计数据
      this.getDataEnterprise()
    })
  }
}
</script>
```

2. 注意：若不想使用**nextTick**，可以将数据的获取放在**mouted**钩子函数中

### git记录

```bash
git add .
git commit -m "数据概述模块--数据概述模块功能完成"
git checkout master
git merge chart
git branch -d chart
```

## 14-项目打包

### 项目优化

#### 添加进度条效果

* 步骤：
  1. 安装**nprogress**运行依赖
  2. 打开`request.js`文件，导入进度条插件，在**axios**请求拦截器添加**Nprogress.start()**，在**axios**相应拦截器添加**Nprogress.done()**

#### 移除开发阶段的所有**console**信息

1. 打开项目控制台，点击依赖-->开发依赖；
2. 输入`babel-plugin-transform-remove-console`进行安装；
3. 打开**babel.config.js**文件，编辑以下代码

```javascript
// 项目发布阶段需要用到的babel插件
const productPlugins = []

// 判断是开发还是发布阶段
if(process.env.NODE_ENV === 'production'){
  // 发布阶段
  productPlugins.push("transform-remove-console")
}

module.exports = {
  "presets": [
    "@vue/app"
  ],
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ],
    ...productPlugins
  ]
}
```

#### 修改**webpack**默认配置

​	默认情况下，vue-cli 3.0生成的项目，隐藏了webpack配置项，如果我们需要配置webpack
需要通过vue.config.js来配置。

- 将**main.js**文件复制改成**main-dev.js**、**main-prod.js**两文件
- 在项目根目录中创建**vue.config.js**文件，编写以下代码：

```javascript
module.exports = {
    chainWebpack:config=>{
        // 发布模式
        config.when(process.env.NODE_ENV === 'production',config=>{
            // entry找到默认的打包入口，调用clear则是删除默认的打包入口
            // add添加新的打包入口
            config.entry('app').clear().add('./src/main-prod.js')
        })
        // 开发模式
        config.when(process.env.NODE_ENV === 'development',config=>{
            config.entry('app').clear().add('./src/main-dev.js')
        })
    }
}
```

#### 加载外部CDN

​	默认情况下，依赖项的所有第三方包都会被打包到`js/chunk-vendors.**.js`文件中,导致该js文件过大，我们可以通过`externals`排除这些包，使它们不被打包到`js/chunk-vendors.******.js`文件中

外部CDN网址：` https://www.bootcdn.cn/ `

```javascript
module.exports = {
    chainWebpack:config=>{
        // 发布模式
        config.when(process.env.NODE_ENV === 'production',config=>{
            // entry找到默认的打包入口，调用clear则是删除默认的打包入口
            // add添加新的打包入口
            config.entry('app').clear().add('./src/main-prod.js')

            // 使用externals设置排除项
            config.set('externals',{
                vue:'Vue',
                'vue-router':'VueRouter',
                axios:'axios',
                echarts:'echarts',
                nprogress:'NProgress',
                'vue-quill-editor':'VueQuillEditor'
            })
        })
        // 开发模式
        config.when(process.env.NODE_ENV === 'development',config=>{
            config.entry('app').clear().add('./src/main-dev.js')
        })
    }
}
```

设置好排除之后，为了使我们能使用vue、axios等内容，需要加载外部CDN的形式解决依赖项。

打开`main-prod.js`文件,删除掉默认的引入代码

```javascript
// 已删掉默认引入的代码
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
import './assets/style/base.css'
import DonMessage from '@/utils/message.js'
// 导入富文本js
import VueQuillEditor from 'vue-quill-editor'
Vue.use(VueQuillEditor)
Vue.prototype.$message = DonMessage
Vue.config.productionTip = false

new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')

```

删掉默认引入的代码，打开`public/index.html`文件添加CDN引入代码

```html
<!-- element-ui的css文件 -->
<link href="https://cdn.bootcss.com/element-ui/2.12.0/theme-chalk/index.css" rel="stylesheet">
<!-- 富文本css文件 -->
<link href="https://cdn.bootcss.com/quill/2.0.0-dev.3/quill.core.min.css" rel="stylesheet">
<link href="https://cdn.bootcss.com/quill/2.0.0-dev.3/quill.snow.min.css" rel="stylesheet">
<link href="https://cdn.bootcss.com/quill/2.0.0-dev.3/quill.bubble.min.css" rel="stylesheet">
<!-- 进度条css文件 -->
<link href="https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">

<!-- Vue的js文件 -->
<script src="https://cdn.bootcss.com/vue/2.6.10/vue.min.js"></script>
<!-- VueRouter的js文件 -->
<!-- <script src="https://cdn.bootcss.com/vue-router/3.1.2/vue-router.min.js"></script> -->
<!-- axios的js文件 -->
<script src="https://cdn.bootcss.com/axios/0.19.0/axios.min.js"></script>
<!-- element-ui的js文件 -->
<script src="https://cdn.bootcss.com/element-ui/2.12.0/index.js"></script>
<!-- 进度条的js文件 -->
<script src="https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
<!-- echart的js文件 -->
<script src="https://cdn.bootcss.com/echarts/4.4.0-rc.1/echarts.min.js"></script>
```

#### 路由懒加载

​	当路由被访问时才加载对应的路由文件，就是路由懒加载。

* 路由懒加载实现步骤：
  1. 安装 `@babel/plugin-syntax-dynamic-import`
  2. 打开vue控制台，点击依赖->安装依赖->开发依赖->搜索`@babel/plugin-syntax-dynamic-import`
     点击安装。
  3. 在**babel.config.js**中声明该插件，打开**babel.config.js**

```javascript
// 项目发布阶段需要用到的babel插件
const productPlugins = []

// 判断是开发还是发布阶段
if(process.env.NODE_ENV === 'production'){
  //发布阶段
  productPlugins.push("transform-remove-console")
}

module.exports = {
  "presets": [
    "@vue/app"
  ],
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ],
    ...productPlugins,
    // 配置路由懒加载插件
    "@babel/plugin-syntax-dynamic-import"
  ]
}
```

		4. 将路由更改为按需加载的形式，打开`routes.js`文件，更改引入代码：

```javascript
// 组件-登录页
const login = () => import(/* webpackChunkName:"login" */ '@/views/login/login')
// 组件-首页
const index = () => import(/* webpackChunkName:"index" */ '@/views/index/index')
// 组件-学科
const subject = () => import(/* webpackChunkName:"subject" */ '@/views/index/subject/subject')
// 组件-企业
const enterprise = () => import(/* webpackChunkName:"enterprise" */ '@/views/index/enterprise/enterprise')
// 组件-题库
const question = () => import(/* webpackChunkName:"question" */ '@/views/index/question/question')
// 组件-用户
const user = () => import(/* webpackChunkName:"user" */ '@/views/index/user/user')
// 组件-数据
const chart = () => import(/* webpackChunkName:"chart" */ '@/views/index/chart/chart')
```

